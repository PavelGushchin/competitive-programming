// Задача: I, Вердикт: OK, Время: 325ms, Память: 132.00Kb

// Будем предполагать, что искомое b лежит на некотором отрезке [L, R]
// Изначально оно лежит на отрезке [L, R] = [2, 65536]
// На каждой итерации будем выбирать такое x, чтобы сократить этот отрезок
// Идеи:
// 1) Возьмём такое x, для которого количество цифр для левого конца равно 2,
//    а для правого конца равно 1. Подойдёт любой x от L до L^2 - 1
// 2) Возьмём середину отрезка: x = (L+R)/2
// Мы не можем сразу начать применять идею #2, потому что, например, если мы
// для начального отрезка спросим середину, то чётные и нечётные количества цифр
// будут идти вперемешку и чередоваться, тогда как для идеи #1 будет
// строгая монотонность, поэтому сначала применяем идею #1, потому что есть
// монотонность, а затем начинаем применять идею #2, когда (R+L)/2 не
// станет <= L^2 - 1, то есть начнёт давать монотонные ответы на отрезке [L, R]

#include <bits/stdc++.h>
#define int int64_t // для того чтобы избегать переполнения 32-битного типа
using namespace std;
using pii = pair<int, int>;

// Тестирование: мы можем автоматизировать тестирование. Нам нужно загадать b и
// пусть наш алгоритм общается с функцией тестирования, которая будет считать
// количество запросов

// Самотестирование: загадаем основание b, кол-во запросов q
int b = 2, q = 0; bool selfTest = false;

// Функция len считает длину числа x в системе счисления b - часть тестирования
int len(int x) {
    return x < b ? 1 : 1 + len(x / b);
}

// Функция задаёт вопрос относительно числа x
int ask(int x) {
    q++;
    if (!selfTest) // если не врубили режим тестирования, то спрашиваем в консоли
        cout << "? " << x << endl;
    int res = len(x) % 2;
    if (!selfTest) // если не врубили режим тестирования, то получаем из консоли
        cin >> res;
    return res;
}

void answer(int x) {
    if (!selfTest) // если не врубили режим тестирования, то выводим ответ
        cout << "! " << x << endl;
    else // иначе убедимся, что найденный ответ совпал с тем, которое загадали
        assert(x == b);
}

// Решение задачи
void solve() {
    // Искомое b находится на отрезке [L, R] = [2, 65536]
    int L = 2, R = 65536;
    while (R - L > 0) {
        // спрашиваем такое x, которое сократит длину отрезка
        // для x должна быть монотонность
        int x = std::min(L * L - 1, (L + R) / 2);
        int res = ask(x); // собственно спрашиваем
        if (res == 1) // нечётные ответы справа от x
            L = x + 1;
        else // чётные ответы слева от x (включительно)
            R = x;
    }
    // сообщаем ответ
    answer(L);
}

// Тестирование:
void stress() {
    selfTest = true;
    pii worstCase(0, 1); // пара (кол-во запросов, основание)
    // переберём все возможные основания и для каждого запустим наш алгоритм
    for (b = 2; b <= 65536; b++)
    {
        q = 0; // обнуляем счётчик кол-ва запросов
        solve(); // решаем. внутри проверка, что ответ совпал с b
        worstCase = max(worstCase, pii(q, b));
    }
    cout << "Worst case: " << worstCase.first << " queries for "
         << worstCase.second << endl;
    exit(0);
}
main() {
    //stress(); // раскомментировать, если нужно тестирование алгоритма
    selfTest = false;
    int tt; cin >> tt;
    while (tt --> 0)
        solve();
}
