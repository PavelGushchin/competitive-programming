# Задача: I, Вердикт: OK, Время: 0.852s, Память: 40.87Mb

# Будем предполагать, что искомое b лежит на некотором отрезке [L, R]
# Изначально оно лежит на отрезке [L, R] = [2, 65536]
# На каждой итерации будем выбирать такое x, чтобы сократить этот отрезок
# Идеи:
# 1) Возьмём такое x, для которого количество цифр для левого конца равно 2,
#    а для правого конца равно 1. Подойдёт любой x от L до L^2 - 1
# 2) Возьмём середину отрезка: x = (L+R)/2
# Мы не можем сразу начать применять идею #2, потому что, например, если мы
# для начального отрезка спросим середину, то чётные и нечётные количества цифр
# будут идти вперемешку и чередоваться, тогда как для идеи #1 будет
# строгая монотонность, поэтому сначала применяем идею #1, потому что есть
# монотонность, а затем начинаем применять идею #2, когда (R+L)/2 не
# станет <= L^2 - 1, то есть начнёт давать монотонные ответы на отрезке [L, R]

import sys

# Самотестирование: загадаем основание b, кол-во запросов q
b = 2
q = 0
selfTest = False  # в режиме самотестирования внешний ввод/вывод не используется

# Функция len_b считает длину числа x в системе счисления b - часть тестирования
def len_b(x: int) -> int:
    return 1 if x < b else 1 + len_b(x // b)

# Функция задаёт вопрос относительно числа x
def ask(x: int) -> int:
    global q
    q += 1
    if not selfTest:
        # В интерактивном режиме важно сразу отправлять запрос судье:
        print(f"? {x}", flush=True)  # flush=True форсирует сброс буфера вывода
        res = int(input().strip())
        return res
    # В самотестировании считаем ответ по определению: нечётность длины в базе b
    return len_b(x) % 2

def answer(x: int) -> None:
    if not selfTest:
        print(f"! {x}", flush=True)
    else:
        # В самотестировании проверяем корректность найденного ответа
        assert x == b

# Решение задачи
def solve() -> None:
    # Искомое b находится на отрезке [L, R] = [2, 65536]
    L, R = 2, 65536
    while R - L > 0:
        # спрашиваем такое x, которое сократит длину отрезка
        # для x должна быть монотонность
        x = min(L * L - 1, (L + R) // 2)
        res = ask(x)  # собственно спрашиваем
        if res == 1:  # нечётные ответы справа от x
            L = x + 1
        else:         # чётные ответы слева от x (включительно)
            R = x
    # сообщаем ответ
    answer(L)

# Тестирование:
def stress() -> None:
    global selfTest, q, b
    selfTest = True
    worstCase = (0, 1)  # пара (кол-во запросов, основание)
    # переберём все возможные основания и для каждого запустим наш алгоритм
    for base in range(2, 65536 + 1):
        b = base
        q = 0  # обнуляем счётчик кол-ва запросов
        solve()  # решаем. внутри проверка, что ответ совпал с b
        if (q, b) > worstCase:
            worstCase = (q, b)
    print(f"Worst case: {worstCase[0]} queries for {worstCase[1]}")
    sys.exit(0)

def main() -> None:
    # stress()  # раскомментировать, если нужно тестирование алгоритма
    global selfTest
    selfTest = False
    tt = int(input())
    for _ in range(tt):
        solve()

if __name__ == "__main__":
    main()
