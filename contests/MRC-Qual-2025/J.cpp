// Задача: J, Вердикт: OK, Время: 310ms, Память: 23.18Mb

// В задаче требуется найти вес минимального остовного дерева (MST) во взвешанном
// графе. Будем искать его с помощью алгоритма Прима. Вес рёбер зависит от
// параметра "x" линейно, поэтому, если "x" может изменяться в пределах отрезка
// [L, R], то минимум по "x" достигается на концах отрезка. Найдём вес MST при
// x = L и при x = R. В качестве ответа выведем минимум из двух вариантов.

#include <bits/stdc++.h>
#define int int64_t
using namespace std;
using tiii = tuple<int,int,int>;
using pii = pair<int,int>;

bool solve() {
// функция solve читает текущий тест и возвращает true, если прочла, иначе false
// решает задачу для текущего теста и выводит ответ на него

    // читаем количество вершин, ребёр, и границы по x:
    int n, m, l, r;
    cin >> n >> m >> l >> r;
    if (n == 0) // тесты кончились
        return false;
    
    // читаем рёбра графа и сохраняем их в виде списков смежности
    // adj[u] = {(v, a, b)}: список рёбер u->v из вершины u с параметрами (a, b)
    vector adj(1+n, vector<tiii>());
    for (int i = 0; i < m; i++) {
        int u, v, a, b;
        cin >> u >> v >> a >> b;
        adj[u].emplace_back(v, a, b);
        adj[v].emplace_back(u, a, b);
    }
    // лямбда функция findAnswer находит ответ для заданного значения x
    // находим вес минимального остовного дерева алгоритмом Прима
    auto findAnswer = [&](int x)
    {
        // алгоритм Прима жадно идёт каждый раз по ребру минимального веса в
        // соседнюю (к посещённым) ещё непосещённую вершину
        // в очереди с приоритетами храним пары (вес ребра, номер вершины)
        int answ{};
        vector<bool> used(1+n, false);
        priority_queue<pii, vector<pii>, greater<pii>> queue;
        // изначально заносим в очередь только вершину номер 1. Начнём с неё:
        queue.push({0, 1});
        while (queue.size()) {
            // извлекаем текущую вершину и её вес из очереди
            auto [cost, u] = queue.top();
            queue.pop();
            // если вершина уже посещена, то пропускаем её
            if (used[u])
                continue;
            // отмечаем текущую вершину посещённой и увеличиваем ответ
            used[u] = true;
            answ += cost;
            // добавляем в очередь все смежные с текущей вершиной рёбра
            for (const auto &[v, a, b] : adj[u])
                queue.push({a + b * x, v});
        }
        return answ;
    };
    // в силу того, что функции на рёбрах - линейные, то минимум достигается
    // на одном из концов отрезка. Проверим x = l и x = r и выберем минимум
    cout << min(findAnswer(l), findAnswer(r)) << endl;
    return true;
}
main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    while (solve());
}
