// Задача: B, Вердикт: OK, Время: 0.039 сек, Память: 2 MB

// Идея решения: если есть только две одинаковые кучки, то ход единственный.
// Выполняем его и придём к обработке случая трёх одинаковых кучек.
// Теперь случай трёх одинаковых кучек: тот, кто делает ход, может выбрать две
// любые кучки. После его хода снова придём к случаю, когда только две кучки
// с одинаковыми буквами, поэтому у его соперника будет единственный ход.
// Зная это, мы должны выбрать такие две кучки, чтобы поставить соперника в тупик.
// Разбор случаев зависит от чётности кучек. Подробнее в комментариях к решению.
// Возможно некоторые случаи избыточны, но работает - не трогай.

#include <bits/stdc++.h>
#define int int64_t
using namespace std;

char opposite(char c) {
    return char('B' - c + 'A');
}

void makeMove(int &whoMakesMove, char &c1, char &c2, int &n1, int &n2) {
    whoMakesMove = 1 - whoMakesMove;
    n1--;
    n2--;
    c1 = opposite(c1);
    c2 = opposite(c2);
}

int solve(char c1, char c2, char c3, int n1, int n2, int n3) {
    int whoMakesMove = 1;
    // в ситуации, когда есть только две одинаковые буквы, у нас единственный
    // ход над двумя кучками, делаем его
    if (c1 == c2 && c1 != c3) makeMove(whoMakesMove, c1, c2, n1, n2);
    else if (c1 == c3 && c1 != c2) makeMove(whoMakesMove, c1, c3, n1, n3);
    else if (c2 == c3 && c2 != c1) makeMove(whoMakesMove, c2, c3, n2, n3);
    // теперь у нас все три кучки оканчиваются на одну и ту же букву
    // находящийся в этой ситуации игрок может выбрать любые две кучки и сделать
    // ход. Его оппонент обязан повторять за ним, так как у него будет доступен
    // единственный ход, и он обязан его сделать.
    // Здесь начинается разбор случаев какими по чётности могут быть три кучки
    // Итак, если все кучки чётные, то тот, кто делает ход, проигрывает:
    if (n1 % 2 == 0 && n2 % 2 == 0 && n3 % 2 == 0) {
        // проигрываем тот, чей сейчас ход
        return 1 - whoMakesMove;
    }
    // иначе отсортируем кучки по возрастанию размера:
    if (n1 > n2) swap(n1, n2);
    if (n1 > n3) swap(n1, n3);
    if (n2 > n3) swap(n2, n3);
    // если есть две пустые кучки, то ход не возможен - мы проиграли
    if (n1 == 0 && n2 == 0)
        return 1 - whoMakesMove;
    // если ровно одна пустая кучка, то все ходы однозначны
    // выигрыш зависит от чётности второй кучки
    if (n1 == 0)
        return (n2 % 2 == 0) ? (1 - whoMakesMove) : whoMakesMove;
    // теперь все три кучки ненулевые
    // если есть две нечётные кучки, то мы выиграли. Всё время выбираем их и ставим
    // оппонента в тупик!
    if ((n1 % 2) + (n2 % 2) + (n3 % 2) >= 2)
        return whoMakesMove;
    // теперь у нас последний случай: одна кучка нечётная, а две другие - чётные
    // у нас ровно один способ победить: каждый раз выбирать чётную и нечётную кучки
    // мы можем победить, если сумма чётных >= размер нечётной кучки
    assert((n1 % 2) || (n2 % 2) || (n3 % 2));
    int oddSize = n1;
    if (oddSize % 2 == 0) oddSize = n2;
    if (oddSize % 2 == 0) oddSize = n3;
    assert(oddSize % 2 == 1);
    int evenSum = (n1 + n2 + n3) - oddSize;
    // проверяем единственное условие победы для этого случая:
    if (evenSum >= oddSize)
        return whoMakesMove;
    // иначе мы проиграли!
    return 1 - whoMakesMove;
}
void solve() {
    char c1, c2, c3;
    int n1, n2, n3;
    cin >> c1 >> n1 >> c2 >> n2 >> c3 >> n3;
    cout << solve(c1, c2, c3, n1, n2, n3) << endl;
}
main() {
    int tt; cin >> tt;
    while (tt --> 0)
        solve();
}
