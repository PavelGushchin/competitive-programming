# Задача: B, Вердикт: OK, Время: 0.518 сек, Память: 114 MB

# Идея решения: если есть только две одинаковые кучки, то ход единственный.
# Выполняем его и придём к обработке случая трёх одинаковых кучек.
# Теперь случай трёх одинаковых кучек: тот, кто делает ход, может выбрать две
# любые кучки. После его хода снова придём к случаю, когда только две кучки
# с одинаковыми буквами, поэтому у его соперника будет единственный ход.
# Зная это, мы должны выбрать такие две кучки, чтобы поставить соперника в тупик.
# Разбор случаев зависит от чётности кучек. Подробнее в комментариях к решению.
# Возможно некоторые случаи избыточны, но работает - не трогай.

def opposite(c):
    return chr(ord('B') - ord(c) + ord('A'))

def make_move(who_makes_move, c1, c2, n1, n2):
    who_makes_move = 1 - who_makes_move
    n1 -= 1
    n2 -= 1
    c1 = opposite(c1)
    c2 = opposite(c2)
    return who_makes_move, c1, c2, n1, n2

def solve(c1, c2, c3, n1, n2, n3):
    who_makes_move = 1
    # в ситуации, когда есть только две одинаковые буквы, у нас единственный
    # ход над двумя кучками, делаем его
    if c1 == c2 and c1 != c3:
        who_makes_move, c1, c2, n1, n2 = make_move(who_makes_move, c1, c2, n1, n2)
    elif c1 == c3 and c1 != c2:
        who_makes_move, c1, c3, n1, n3 = make_move(who_makes_move, c1, c3, n1, n3)
    elif c2 == c3 and c2 != c1:
        who_makes_move, c2, c3, n2, n3 = make_move(who_makes_move, c2, c3, n2, n3)
    # теперь у нас все три кучки оканчиваются на одну и ту же букву
    # находящийся в этой ситуации игрок может выбрать любые две кучки и сделать
    # ход. Его оппонент обязан повторять за ним, так как у него будет доступен
    # единственный ход, и он обязан его сделать.
    # Здесь начинается разбор случаев какими по чётности могут быть три кучки
    # Итак, если все кучки чётные, то тот, кто делает ход, проигрывает:
    if n1 % 2 == 0 and n2 % 2 == 0 and n3 % 2 == 0:
        # проигрываем тот, чей сейчас ход
        return 1 - who_makes_move
    # иначе отсортируем кучки по возрастанию размера:
    if n1 > n2:
        n1, n2 = n2, n1
    if n1 > n3:
        n1, n3 = n3, n1
    if n2 > n3:
        n2, n3 = n3, n2
    # если есть две пустые кучки, то ход не возможен - мы проиграли
    if n1 == 0 and n2 == 0:
        return 1 - who_makes_move
    # если ровно одна пустая кучка, то все ходы однозначны
    # выигрыш зависит от чётности второй кучки
    if n1 == 0:
        return 1 - who_makes_move if n2 % 2 == 0 else who_makes_move
    # теперь все три кучки ненулевые
    # если есть две нечётные кучки, то мы выиграли. Всё время выбираем их и ставим
    # оппонента в тупик!
    if (n1 % 2) + (n2 % 2) + (n3 % 2) >= 2:
        return who_makes_move
    # теперь у нас последний случай: одна кучка нечётная, а две другие - чётные
    # у нас ровно один способ победить: каждый раз выбирать чётную и нечётную кучки
    # мы можем победить, если сумма чётных >= размер нечётной кучки
    # проверяем единственное условие победы для этого случая:
    odd_size = n1 if n1 % 2 == 1 else (n2 if n2 % 2 == 1 else n3)
    even_sum = n1 + n2 + n3 - odd_size
    if even_sum >= odd_size:
        return who_makes_move
    # иначе мы проиграли!
    return 1 - who_makes_move

def main():
    tt = int(input())
    for _ in range(tt):
        c1, n1 = input().split()
        c2, n2 = input().split()
        c3, n3 = input().split()
        n1, n2, n3 = int(n1), int(n2), int(n3)
        print(solve(c1, c2, c3, n1, n2, n3))

if __name__ == "__main__":
    main()
