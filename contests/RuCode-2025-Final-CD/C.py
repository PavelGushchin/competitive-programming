# Задача: C, Вердикт: OK, Время: 0.130 сек, Память: 111 МБ

# Идея решения: сумма цифр в числе очень быстро убывает и становится однозначной
# от 1 до 9 при многократном применении. Сумма цифр в n из отрезка [1, 10^{12}]
# до 9 * 12 - худший случай. Поэтому переберём сумму цифр. Далее посчитаем хвост
# от повторного применения суммы от суммы цифр, и т.д. Вычтем посчитанные слагаемые
# из числа n. Таким образом, мы вычислим искомое число x. Проверим его сумму цифр:
# равна ли она тому значению, которое мы зафиксировали.

# функция считает сумму цифр в числе:
def sumDigits(x: int) -> int:
    # В Python рекурсия здесь безопасна, т.к. глубина равна количеству цифр (до 12).
    return x if x <= 9 else (x % 10 + sumDigits(x // 10))

def solve_instance(n: int, k: int):
    # если k == 0, то уравнение состоит из одного слагаемого и решение однозначно:
    if k == 0:
        return [n]
    # иначе переберём сумму цифр в числе x. Она будет от 1 до 9 * 12
    answ = []
    for sumX in range(1, 9 * 12 + 1):
        # посчитаем остальные слагаемые: S(S(x)), S(S(S(x))), и т.д.
        # сумма суммы цифр очень быстро превращается в одно число
        lastTerm = sumX
        x = n - sumX
        for i in range(2, k + 1):
            currTerm = sumDigits(lastTerm)
            if currTerm == lastTerm:
                # сумма цифр вырожденная, можем посчитать по формуле
                # все остальные слагаемые от i до k:
                x -= (k - i + 1) * lastTerm
                break
            # иначе делаем ещё одну итерацию:
            x -= currTerm
            lastTerm = currTerm
        # итак, мы обработали все слагаемые с суммами цифр и знаем x. Мы его
        # вычислили в процессе обработки как:
        # x = n - S(x) - S(S(x)) - ...
        # проверим, что сумма цифр в числе x равна тому значению, которое мы
        # зафиксировали, и тогда мы нашли ещё одно решение
        if x >= 1 and sumDigits(x) == sumX:
            answ.append(x)
    return answ

def main():
    import sys
    data = sys.stdin.read().strip().split()
    it = iter(data)
    tt = int(next(it))
    out_lines = []
    for _ in range(tt):
        n = int(next(it)); k = int(next(it))
        answ = solve_instance(n, k)
        answ.sort()
        out_lines.append(str(len(answ)))
        # печатаем элементы в одной строке, разделяя пробелами; если пусто — печатаем пустую строку
        out_lines.append(' '.join(map(str, answ)))
    print('\n'.join(out_lines))

if __name__ == "__main__":
    main()
