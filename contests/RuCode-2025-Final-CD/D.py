# Задача: D, Вердикт: OK, Время: 0.381 сек, Память: 114 МБ

# Цель: составить последовательность из 0 и 1, расставить OR и AND между ними так,
# чтобы максимизировать сумму результатов применения операций
# Подход:
# Формируем последовательность блоками в фиксированном приоритете:
#   1. Чередующиеся пары [0 1] с операцией OR между ними.
#      - Сначала одиночный блок [0 1] (если возможно), дающий +1.
#      - Затем несколько повторных пар, каждая дает +2 (две операции OR).
#   2. Группа подряд идущих единиц, между которыми ставятся операции AND.
#      - Добавляет +cnt (число поставленных AND), но если слева не было единицы, штраф -1.
#   3. Группа подряд идущих единиц с операцией OR.
#      - Добавляет +cnt, но если последовательность была пустой (len == 0), штраф -1.
#   4. Группа подряд идущих нулей с операцией OR.
#      - Добавляет либо 0, либо +1 (если слева была единица) — за первый OR переход от 1 к 0.
#
# Переменные состояния:
#   last — последний поставленный символ (0 или 1), нужно для штрафов/бонусов на переходах.
#   len  — текущая длина сформированной последовательности.
#
# Обработка крайних случаев:
#   - Если нет нулей (n0 == 0): можно ставить только единицы -> ответ n1 - 1 (все AND/OR между ними кроме первого).
#   - Если нет единиц (n1 == 0): ответ 0 (нельзя сформировать полезные переходы).

def compute_answer(n0: int, n1: int, nOR: int) -> int:
    # Крайние случаи:
    if n0 == 0:
        return n1 - 1  # Только единицы: между n1 элементами ровно n1-1 операций.
    if n1 == 0:
        return 0       # Только нули

    # Вычисляем доступные операции AND.
    nAND = n0 + n1 - 1 - nOR

    ans = 0       # Итоговый счёт.
    last = 0      # Последний поставленный символ (0 или 1).
    length = 0    # Текущая длина построенной последовательности.

    # 1. Поставим один блок [0 1] (если возможно) с операцией OR.
    if n0 > 0 and n1 > 0 and nOR >= 1:
        n0 -= 1
        n1 -= 1
        nOR -= 1
        ans += 1
        length += 2
        last = 1  # Последним теперь стоит '1'

    # 1 (продолжение). Ставим дополнительные чередующиеся пары [0 1] с двумя OR внутри каждой пары.
    # Для каждой пары нужны: 1 ноль, 1 единица и 2 операции OR.
    cnt = min(n0, n1, nOR // 2)
    if cnt > 0:
        n0 -= cnt
        n1 -= cnt
        nOR -= 2 * cnt
        ans += 2 * cnt     # Каждая пара даёт 2 OR
        length += 2 * cnt
        last = 1           # Завершается на '1'

    # 2. Ставим подряд единицы со связкой AND (каждая AND между двумя соседними единицами).
    cnt = min(n1, nAND)
    if cnt > 0:
        n1 -= cnt
        nAND -= cnt
        ans += cnt         # Каждый AND даёт +1
        if last == 0:
            ans -= 1       # Штраф: если переход с '0' к первому блоку единиц (нужно было "соединить")
        last = 1
        length += cnt

    # 3. Ставим подряд оставшиеся единицы с операцией OR между ними.
    cnt = min(n1, nOR)
    if cnt > 0:
        n1 -= cnt
        nOR -= cnt
        ans += cnt
        if length == 0:
            ans -= 1       # Штраф: если это самый первый блок (не было перед ним элемента)
        last = 1
        length += cnt

    # 4. Ставим нули подряд с операцией OR.
    cnt = min(n0, nOR)
    if cnt > 0:
        n0 -= cnt
        nOR -= cnt
        if last == 1:
            ans += 1       # Бонус за переход единица -> ноль (только один раз)
        last = 0
        length += cnt

    return ans


def solve_case():
    # Читает один тест: три целых n0, n1, nOR
    n0, n1, nOR = map(int, input().split())
    print(compute_answer(n0, n1, nOR))


def main():
    # Формат: сначала количество тестов, затем для каждого три числа.
    t = int(input())
    for _ in range(t):
        solve_case()


if __name__ == "__main__":
    main()