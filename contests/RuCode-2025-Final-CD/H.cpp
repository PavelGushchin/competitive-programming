// Задача: H, Вердикт: OK, Время: 0.059 сек, Память: 2 MB

// Самое важное в этой задаче понять, что они могут перемещаться одновременно
// только за время t5 или t6. Все другие способы (t1, t2, t3, t4) выглядят так,
// что одна из лягушек осуществляет перемещение, а вторая стоит на месте и ждёт,
// пока вторая не завершит перемещение на соседнюю кувшинку.
// В связи с этим, решение выглядит следующим образом: пусть между ними расстояние
// dist, а timeA и timeB - время, за которое лягушки A и B делают перемещение навстречу
// друг другу поочерёдно, а timeAB - время, за которое они шагают одновременно.
// Тогда расстояние dist уменьшается на 2 за min(2 * min(timeA, timeB), timeAB) -
// либо самая быстрая лягушка делает два шага, либо они шагают навстречу друг другу.
// Таким образом, мы можем уменьшать расстояние на 2 кувшинки пока dist >= 2.
// При dist == 1 последний шаг делает самая быстрая лягушка за min(timeA, timeB).
// ОСОБЫЙ СЛУЧАЙ: иногда выгодно увеличить dist на 1, а только потом начать сближаться.
// Пусть самая быстрая лягушка отпрыгнет назад, а потом они начнут сближаться.
// Рассмотрим все 4 варианта и выберем минимум:
// 1) сближаемся по дуге AB:
//     a) сразу; b) с отпрыгиванием назад;
// 2) сближаемся по дуге BA:
//     c) сразу; d) с отпрыгиванием назад.
// Ответ: min(a, b, c, d)

#include <bits/stdc++.h>
#define int int64_t

using namespace std;

// функция для вычисления времени сближения напрямик, уменьшая расстояние dist
int solve(int dist, int timeA, int timeB, int timeMeet) {
    // за время timeMeet -> dist-2
    // за время 2 * min(timeA, timeB) -> dist-2
    int answ = (dist / 2) * min<int>(timeMeet, 2 * min<int>(timeA, timeB));
    dist %= 2;
    if (dist)
        answ += min<int>(timeA, timeB);
    return answ;
}

// функция, рассматривающая два варианта:
// --- 1) сближаемся напрямик;
// --- 2) делаем шаг назад и сближаемся напрямик.
int solve(int dist, int timeA, int timeB, int timeAinv, int timeBinv, int timeMeet) {
    return min<int>(
        solve(dist, timeA, timeB, timeMeet),
        solve(dist+1, timeA, timeB, timeMeet) + min<int>(timeAinv, timeBinv)
    );
}

// функция для оригинальных входных данных
int solve(int n, int a, int b, int t1, int t2, int t3, int t4, int t5, int t6) {
    // считаем длину дуги AB:
    int dAB = (a <= b) ? (b - a) : (b + n - a);
    // считаем длину дуги BA:
    int dBA = (b <= a) ? (a - b) : (a + n - b);
    // считаем время для преодоления дуги AB:
    int answAB = solve(dAB, t1, t4, t2, t3, t5);
    // считаем время для преодоления дуги BA:
    int answBA = solve(dBA, t2, t3, t1, t4, t6);
    // берём минимум:
    return min(answAB, answBA);
}

void solve() {
    // решаем задачу для одного набора входных данных:
    int n, a, b, t1, t2, t3, t4, t5, t6;
    cin >> n >> a >> b >> t1 >> t2 >> t3 >> t4 >> t5 >> t6;
    cout << solve(n, a, b, t1, t2, t3, t4, t5, t6) << endl;
}

main() {
    int tt; cin >> tt;
    while (tt --> 0)
        solve();
}