// Задача: I, Вердикт: OK, Время: 0.030 сек, Память: 2 MB

// Задача интерактивная. Всего доступно 300 запросов. По чистой случайности, ровно
// столько простых чисел от 1 до 1986 существует. Совпадение?
// Идея: если сначала спросим 1, то сможем определять делимость загаданного числа
// на простые числа p, потому что НОД(x, p) = 1 или p. НОД равен 1, если x не
// делится на p, и НОД равен p иначе. Так как единица уже была выписана, то
// нам сообщат либо 1, либо 0 - однозначно узнаем.
// Заведём список кандидатов на ответ в порядке возрастания и будем уменьшать
// его размер, задавая уточняющие вопросы относительно делимости на простые p
// до тех пор пока длина массива кандидатов не уменьшится до 1. В этом случае
// сообщаем ответ и переходим к следующему раунду общения с тестирующей системой.

#include <bits/stdc++.h>
#define int int64_t
using namespace std;

// функции для интерактивного общения с тестирующей системой
int ask(int x) {
    cout << "? " << x << endl;
    int res; cin >> res;
    return res;
}

void answer(int x) {
    cout << "! " << x << endl;
}

// решение задачи
void solve() {
    // Первым делом спрашиваем 1:
    ask(1);
    // теперь мы сможем определять, делится ли загаданное число на простое число
    // p, или его степень. Если жюри вернуло 0, то значит НОД(x, p) не был выписан,
    // но этот НОД равен либо p, либо 1. А так как 1 уже был выписан, то x делится
    // на p. Используем это, чтобы сократить список кандидатов, пока список не
    // превратится в одно число!
    vector<int> candidates;
    for (int x = 1; x <= 1986; x++)
        candidates.push_back(x);
    while (candidates.size() >= 2u) {
        int p = candidates[1];
        int res = ask(p);
        // если res == 1, то x не делится на p: обновим список кандидатов,
        // оставив в них те числа, которые не делятся на p.
        // если res == 0, то x делится на p. Аналогично обновим список кандидатов
        int len = 0;
        for (int i = 0; i < (int)candidates.size(); i++)
            if ((candidates[i] % p == 0) == (res == 0))
                candidates[len++] = candidates[i];
        candidates.resize(len);
    }
    // сообщаем ответ:
    answer(candidates.front());
}

main() {
    int tt; cin >> tt;
    while (tt --> 0)
        solve();
}
