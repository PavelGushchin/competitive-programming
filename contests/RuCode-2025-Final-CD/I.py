# Задача: I, Вердикт: OK, Время: 0.173 сек, Память: 110 MB

# Задача интерактивная. Всего доступно 300 запросов. По чистой случайности, ровно
# столько простых чисел от 1 до 1986 существует. Совпадение?
# Идея: если сначала спросим 1, то сможем определять делимость загаданного числа
# на простые числа p, потому что НОД(x, p) = 1 или p. НОД равен 1, если x не
# делится на p, и НОД равен p иначе. Так как единица уже была выписана, то
# нам сообщат либо 1, либо 0 — однозначно узнаем.
# Заведём список кандидатов на ответ в порядке возрастания и будем уменьшать
# его размер, задавая уточняющие вопросы относительно делимости на простые p
# до тех пор пока длина массива кандидатов не уменьшится до 1. В этом случае
# сообщаем ответ и переходим к следующему раунду общения с тестирующей системой.

# Важно для Python: при интерактивном общении используйте print(..., flush=True) и input()
# чтобы гарантировать вывод вопросов и чтение ответов от тестирующей системы.

# функции для интерактивного общения с тестирующей системой
def ask(x: int) -> int:
    print(f"? {x}", flush=True)
    res = int(input())
    return res

def answer(x: int):
    print(f"! {x}", flush=True)

# решение задачи
def solve():
    # Первым делом спрашиваем 1:
    ask(1)
    # теперь мы сможем определять, делится ли загаданное число на простое число
    # p, или его степень. Если жюри вернуло 0, то значит НОД(x, p) не был выписан,
    # но этот НОД равен либо p, либо 1. А так как 1 уже был выписан, то x делится
    # на p. Используем это, чтобы сократить список кандидатов, пока список не
    # превратится в одно число!
    candidates = [x for x in range(1, 1986 + 1)]
    while len(candidates) >= 2:
        p = candidates[1]
        res = ask(p)
        # если res == 1, то x не делится на p: обновим список кандидатов,
        # оставив в них те числа, которые не делятся на p.
        # если res == 0, то x делится на p. Аналогично обновим список кандидатов
        new_candidates = []
        for v in candidates:
            if (v % p == 0) == (res == 0):
                new_candidates.append(v)
        candidates = new_candidates
    # сообщаем ответ:
    answer(candidates[0])

def main():
    tt = int(input())
    for _ in range(tt):
        solve()

if __name__ == "__main__":
    main()
