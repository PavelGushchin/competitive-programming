// Задача: L, Вердикт: OK, Время: 0.216 сек, Память: 36 МБ

// Идея: так как в ксор войдут все числа, то давайте их сразу все включим, посчитав
// ксор на отрезке, а затем будем его увеличивать, выбирая очередное число и
// применяя к нему операцию. Те числа, которые не увеличат ксор, будем игнорить.
// Надо расписать, как применение операции меняет ксор. Действия:
// выкидываем то, что было (a[i]), и добавляем то, что стало (f(a[i]) - 1 - a[i])
// Так как a[i] входит дважды, то оно взаимоуничтожится, поэтому операция изменения
// это ксор с числом f(a[i]) - 1, где f(a[i]) = минимальная степень двойки,
// превосходящая a[i]. Назовём f(a[i]) - 1 битовой маской m[i].
// Решение: считаем ксор на отрезке, считаем, какие битовые маски есть на отрезке,
// и применяем битовые маски в порядке убывания, если они увеличивают ксор.
// Битовых масок не больше 30.
#include <bits/stdc++.h>
using namespace std;
using vi = vector<int>;
using vvi = vector<vi>;
main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, q; cin >> n >> q;
    vi a(n), f(n), m(n); // a[i] - исходное число, f[i] - изменённое операцией
                         // m[i] - битовая маска, используемая в операции
    for (int i = 0; i < n; i++)
        cin >> a[i];
    for (int i = 0; i < n; i++) {
        int k = 0;
        while ((1 << k) <= a[i])
            k++;
        m[i] = (1 << k) - 1;
        f[i] = m[i] ^ a[i];
    }
    // Считаем префикс-суммы для xor на отрезке:
    vi s(n+1);
    for (int i = 0; i < n; i++)
        s[i+1] = s[i] ^ a[i];
    // Пусть прямо сейчас ксор равен x. Дальше мы выбираем, изменить ли какие-то
    // элементы, или не менять их. Допустим, мы захотели поменять какой-то
    // элемент. Что получится? Получим: (x ^= a[i]) ^= (m[i] ^ a[i])
    // Упростим: получится просто x ^= m[i]
    // То есть, мы ксорим x с битовой маской.
    // Получается, f[i] не нужно было и мы зря его сохраняли/предподсчитывали
    // Для каждого разряда в префикс-суммах предподсчитаем какие битовые маски
    // m[i] есть в распоряжении.
    vvi cnt(n+1, vi(30));
    for (int i = 0; i < n; i++) {
        cnt[i+1] = cnt[i];
        if (m[i] > 0)
            cnt[i+1][__lg(m[i])]++;
    }
    // начинаем отвечать на запросы:
    vi curr(30);
    while (q --> 0) {
        // читаем границы запроса и считаем количество каждой m[i] на отрезке:
        int l, r; cin >> l >> r;
        for (int i = 0; i < 30; i++)
            curr[i] = cnt[r][i] - cnt[l-1][i];
        // считаем ксор всех чисел на отрезке прямо сейчас:
        int x = s[r] ^ s[l-1];
        // начинаем применять имеющиеся в наличии m[i] чтобы увеличить ксор:
        for (int i = 29; i >= 0; i--)
            // если i-й разряд равен нулю, то мы можем его выставить в 1,
            // заюзав m[i], если оно есть в наличии на отрезке
            if (((x >> i) & 1) == 0 && curr[i] > 0)
                x ^= (1 << (i+1)) - 1;
        // выводим ответ:
        cout << x << '\n';
    }
}
