# Задача: L, Вердикт: OK, Время: 0.712, Память: 247 МБ
#
# Идея: так как в ксор войдут все числа, то давайте их сразу все включим, посчитав
# ксор на отрезке, а затем будем его увеличивать, выбирая очередное число и
# применяя к нему операцию. Те числа, которые не увеличат ксор, будем игнорить.
# Надо расписать, как применение операции меняет ксор. Действия:
# выкидываем то, что было (a[i]), и добавляем то, что стало (f(a[i]) - 1 - a[i])
# Так как a[i] входит дважды, то оно взаимоуничтожится, поэтому операция изменения
# это ксор с числом f(a[i]) - 1, где f(a[i]) = минимальная степень двойки,
# превосходящая a[i]. Назовём f(a[i]) - 1 битовой маской m[i].
# Решение: считаем ксор на отрезке, считаем, какие битовые маски есть на отрезке,
# и применяем битовые маски в порядке убывания, если они увеличивают ксор.
# Битовых масок не больше 30.
#
# Примечания по Python:
# - Быстрый ввод: используем sys.stdin.buffer.read и разбор целых чисел одним массивом.
# - Индекс старшего установленного бита для числа x > 0: x.bit_length() - 1.
# - Маска m[i] = (1 << a[i].bit_length()) - 1 (даёт 0 для a[i] == 0).

import sys

data = list(map(int, sys.stdin.buffer.read().split()))
it = iter(data)

n = next(it)
q = next(it)

# a[i] - исходное число
a = [next(it) for _ in range(n)]

# m[i] - битовая маска, используемая в операции
# f[i] сохранять не нужно, т.к. изменение x при выборе i есть просто x ^= m[i]
m = [0] * n
for i in range(n):
    # k = a[i].bit_length(); m[i] = (1 << k) - 1
    # для a[i] == 0 даёт m[i] == 0
    k = a[i].bit_length()
    m[i] = (1 << k) - 1

# Считаем префикс-суммы для xor на отрезке:
s = [0] * (n + 1)
for i in range(n):
    s[i + 1] = s[i] ^ a[i]

# Для каждого разряда в префикс-суммах предподсчитаем, какие битовые маски m[i] есть.
# cnt[pos][b] — сколько масок с __lg(m[i]) == b на префиксе [1..pos]
# В Python __lg(m[i]) это m[i].bit_length() - 1, если m[i] > 0.
B = 30  # битовых масок не больше 30
cnt = [[0] * B for _ in range(n + 1)]
for i in range(n):
    cnt[i + 1] = cnt[i][:]  # копия накопленного счётчика
    if m[i] > 0:
        b = m[i].bit_length() - 1
        cnt[i + 1][b] += 1

out_lines = []
curr = [0] * B

while q > 0:
    q -= 1
    # читаем границы запроса и считаем количество каждой m[i] на отрезке:
    l = next(it)
    r = next(it)

    for b in range(B):
        curr[b] = cnt[r][b] - cnt[l - 1][b]

    # считаем ксор всех чисел на отрезке прямо сейчас:
    x = s[r] ^ s[l - 1]

    # начинаем применять имеющиеся в наличии m[i], чтобы увеличить ксор:
    # если i-й разряд x равен 0 и есть маска с высшим битом i, выгодно сделать x ^= (1<<(i+1)) - 1
    for i in range(B - 1, -1, -1):
        if ((x >> i) & 1) == 0 and curr[i] > 0:
            x ^= (1 << (i + 1)) - 1

    # выводим ответ:
    out_lines.append(str(x))

sys.stdout.write("\n".join(out_lines))
