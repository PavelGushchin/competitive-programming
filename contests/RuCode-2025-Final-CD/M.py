# Задача: M, Вердикт: OK, Время: 0.088 сек, Память: 111 MB

# Идея: будем работать с остатками по модулю 60. Нужно добиться остатка равного 0.
# добавляя букву в конец, остаток меняется по формуле: (rem * 16 + newDigit) % 60.
# Добавляя в начало строки, нужно знать длину строки, тогда остаток меняется по
# формуле (rem + newDigit * 16^{len}) % 60.
# Ответ находится довольно быстро, потому что мы уже имеем какой-то остаток на
# отрезке [0, 59] и нам нужно его добить до 0, добавляя цифры 10-15.
# Для поиска оптимального ответа запустим алгоритм поиска в ширину. Переходы:
# добавления букв в начало или конец. Среди лучших по длине ответов найдём
# лексикографически минимальную строку и выведем её.

# служебные функции для удобства при решении задачи:

# бинарное возведение в степень по модулю mod:
def modPow(a: int, n: int, mod: int) -> int:
    # В Python можно использовать встроенную pow(a, n, mod), что быстрее и короче.
    return pow(a, n, mod)

# получение значения цифры, записанной в 16-ричной системе:
def digit(c: str) -> int:
    assert 'A' <= c <= 'F'
    return ord(c) - ord('A') + 10

# конвертация строки в пару (длина строки, остаток от деления на 60)
def convert(s: str):
    # возвращаем длину числа и остаток от деления на 60:
    n = len(s)
    rem = 0
    for ch in s:
        rem = (rem * 16 + digit(ch)) % 60
    return (n, rem)

# преобразование массива, содержащего количество добавленных букв, в строку:
def arrToStr(cnt):
    res = []
    for i in range(6):
        if cnt[i] > 0:
            res.append(chr(ord('A') + i) * cnt[i])
    res = ''.join(res)
    if not res:
        res = "OK"
    return res

# решение задачи:
# запустим поиск в ширину, чтобы найти оптимальный способ дополнить исходную строку
# чтобы получить остаток 0. Так как нам нужно набрать разность от 0 до 59, нам не
# понадобится много букв, так как мы можем варьировать остаток, добавляя от 10 до 15
from collections import deque

def solve_pair(start_len_rem):
    # в очереди храним: ((длина, остаток), [количество добавленных букв A-F])
    # Важно для Python: списки — изменяемые объекты, поэтому при добавлении в очередь
    # нужно копировать массив счётчиков, чтобы избежать aliasing между состояниями.
    que = deque()
    que.append((start_len_rem, [0, 0, 0, 0, 0, 0]))
    bestLen = 10**18
    answ = []
    while que:
        (length, rem), letters = que.popleft()
        if rem == 0:
            # получили остаток равный 0. Обновим оптимальную длину ответа и
            # множество различных наборов букв, которые его достигают:
            if bestLen > length:
                bestLen = length
            if bestLen == length:
                answ.append(arrToStr(letters))
            continue
        # нет смысла обрабатывать варианты, которые превысили по длине
        # оптимальный ответ (по условию), пропускаем.
        if length >= bestLen:
            continue
        # переберём добавления букв в конец:
        for i in range(6):
            d = 10 + i
            newRem = (rem * 16 + d) % 60
            new_letters = letters.copy()
            new_letters[i] += 1
            que.append(((length + 1, newRem), new_letters))
        # переберём добавления букв в начало:
        for i in range(6):
            d = 10 + i
            # можно использовать modPow(16, length, 60) или встроенную pow:
            newRem = (modPow(16, length, 60) * d + rem) % 60
            new_letters = letters.copy()
            new_letters[i] += 1
            que.append(((length + 1, newRem), new_letters))
    # выводим лексикографический минимум:
    return min(answ)

def solve_string(s: str) -> str:
    return solve_pair(convert(s))

def main():
    s = input().strip()
    print(solve_string(s))

if __name__ == "__main__":
    main()
