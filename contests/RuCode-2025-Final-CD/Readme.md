### Содержание
- A — матожидание длины максимальной римской подстроки
- B — игра с тремя кучками и инверсиями букв
- C — уравнение с повторной суммой цифр
- D — максимум суммы OR/AND по нулям и единицам
- E — делители и минимальная система счисления для EF
- F — периметр, делимость на катет и Пифагор
- H — две лягушки на круге, синхронные и одиночные прыжки
- I — интерактив: фильтрация кандидатов делимостью, хитрость с «1»
- M — добивание остатка по модулю 60 двусторонними добавлениями (BFS)

### Как читать
В каждой секции: идея, корректность/интуиция, реализация, сложность, ошибки и примечания к языку (если есть), чтобы быстро сопоставить со своим подходом и закрыть пробелы.

***

### A. Матожидание длины максимальной римской подстроки

Идея :
- По определению математического ожидания: $\mathbb{E} = \sum_{k=1}^{15} k \cdot \frac{f(n,k)}{7^n}$, где $f(n,k)$ — число строк длины $n$ над алфавитом {M,D,C,L,X,V,I}, у которых длина максимальной римской подстроки ровно $k$.
- Сведём к динамике по префиксам: храним римский суффикс строки как «последнее римское число» и максимум длины римской подстроки на этом префиксе.

Модель ДП :
- Состояние: $dp[len][last][k]$ — число строк длины len, оканчивающихся римским числом last (код от 0 до 3999), с текущим максимумом длины римской подстроки $k$.
- Переход: добавляем символ c {M,D,C,L,X,V,I}, пересчитываем максимальный римский суффикс в строке (last + c), его длину L и делаем $dp[len+1][newLast][\max(k,L)]$ += $dp[len][last][k]$.
- Затем $f(n,k) = \sum_{last=1}^{3999} dp[n][last][k]$ и ответ равен $\sum_{k=1}^{15} k \cdot f(n,k) / 7^n$ по модулю $998244353$ с использованием обратного элемента для деления.

Подготовка данных:
- Предварительно строим все римские записи 1..3999 и ассоциируем мапой строку → число, что позволяет проверять «максимальный римский суффикс» у строки за счёт перебора суффиксов и поиска в словаре.
- Предподсчитываем переходы nextRoman[prevNumber][ic] для каждой пары «текущее римское число, добавляемая буква», что критично для скорости основной ДП.

Корректность:
- Римский суффикс после добавления символа единственно определяется как самый длинный суффикс, являющийся корректной римской записью, что и моделирует переход nextRoman.
- Максимум длины римской подстроки поддерживается монотонно как $\max$ от предыдущего значения и длины нового римского суффикса, что эквивалентно определению максимальной римской подстроки в префиксах.
- Линейность матожидания с подсчётом количества конфигураций даёт формулу ожидания через $f(n,k)$ и равномерное число строк $7^n$.

Реализация и детали модуля :
- Используется двуслойная ДП на last×k для экономии памяти, модульные операции add/mul/pow/inv/div с модом $998244353$.
- Начальное состояние dp = 1, где «0» — пустая римская строка, длиной 0.
- В конце суммируем по last и k, затем делим на $7^n$ с помощью обратного по модулю.

Сложность:
- Предподсчёт переходов: $O(4000 \cdot 7 \cdot L)$, где L — длина проверяемых суффиксов (маленькая константа в среднем).
- Основная ДП: $O(n \cdot 4000 \cdot 7 \cdot 16)$, оценочно порядка $7.5 \cdot 10^8$ элементарных операций в худшем случае, что требует агрессивной оптимизации (Ofast, unroll-loops, компактные типы).

Подводные камни :
- Корректность таблицы всех римских чисел 1..3999 и строгая каноничность записи важны для уникальности переходов.
- Нельзя забывать, что last=0 соответствует пустому суффиксу, и переходы из него также допустимы.
- Деление по модулю выполняется умножением на обратный элемент $7^{-n}$, прямое деление недопустимо.

Полезные фрагменты :
- Переход при добавлении символа:
```cpp
int nextNumber = nextRoman[prevNumber][ic];
int L = (int)roman[nextNumber].size();
int nextAnswer = max(prevAnswer, L);
modAddTo(dpNext[nextNumber][nextAnswer], dpCurr[prevNumber][prevAnswer]);
```
.

***

### B. Игра с тремя кучками и инверсиями букв

Постановка в терминах решения :
- Есть три кучки с буквами на вершине, на каждом ходе выбираются две кучки, их размеры уменьшаются на 1, а буквы инвертируются функцией opposite (A↔B).
- Возвращается идентификатор победителя при оптимальной игре, где ход невозможен означает поражение текущего игрока.

Идея и инварианты :
- Если на столе две одинаковые и одна отличная буквы, то ход единственный: нужно тронуть те две, что совпадают, после чего все три станут одинаковыми, и игра переходит в «симметрический» режим.
- В режиме «все три вершины одинаковы» активный игрок волен выбирать любые две кучки, а затем у оппонента снова будет единственный ответ, то есть инициатор контролирует «пары» ходов и должен завести позицию в проигрыш для соперника.

Полный разбор случаев (после доведения букв к одинаковым) :
- Если все три размера чётные, текущий игрок проигрывает, так как каждое «сдвоенное» уменьшение на 2 приводит в позицию того же типа и паритет не даёт шанса сломать симметрию в свою пользу.
- Отсортируем размеры по возрастанию и разберём крайние случаи пустот: если две кучки пусты, то ход невозможен и текущий игрок немедленно проигрывает.
- Если ровно одна пустая кучка, то дальнейшие ходы однозначны и исход определяется чётностью второй кучки: чётная — проигрыш текущего, нечётная — выигрыш текущего.
- Если среди трёх хотя бы две нечётные, у текущего игрока есть выигрышная стратегия, выбирая на каждом шаге две нечётные и сохраняя контроль.
- Если одна кучка нечётная, две чётные, то выигрыш возможен тогда и только тогда, когда сумма чётных не меньше нечётной: выбирая каждый раз пару «чётная+нечётная», текущий игрок доводит до тупика соперника, иначе проигрывает.

Корректность и интуиция :
- Приведение букв к одинаковым фиксирует «структуру выбора» и позволяет анализировать только паритеты и нули, так как буквы потом зеркально следуют друг за другом.
- Случай с одной нечётной редуцируется к ресурсу «масса чётных против размера нечётной», что даёт точное условие выигрыша.

Реализация :
- Сначала применяем единственный принудительный ход, когда есть «две одинаковые, одна другая», после чего все три вершины совпадают по букве.
- Дальше пошагово применяем описанный разбор по паритетам и нулям с сортировкой размеров и возвратом победителя.

Сложность :
- Время и память — $O(1)$, только константные вычисления и сравнения.

Подводные камни :
- Не забыть выполнить принудительный ход с «двумя одинаковыми» перед разбором, иначе логика по паритетам станет неверной.
- Аккуратно обработать нулевые кучки и сортировку, чтобы не пропустить граничные случаи.

Полезные фрагменты :
```cpp
if (n1 % 2 == 0 && n2 % 2 == 0 && n3 % 2 == 0) return 1 - whoMakesMove;
if (n1 > n2) swap(n1, n2);
if (n1 > n3) swap(n1, n3);
if (n2 > n3) swap(n2, n3);
if (n1 == 0 && n2 == 0) return 1 - whoMakesMove;
if (n1 == 0) return (n2 % 2 == 0) ? (1 - whoMakesMove) : whoMakesMove;
if ((n1 % 2) + (n2 % 2) + (n3 % 2) >= 2) return whoMakesMove;
int odd = (n1 % 2 ? n1 : (n2 % 2 ? n2 : n3));
int evenSum = n1 + n2 + n3 - odd;
return (evenSum >= odd) ? whoMakesMove : (1 - whoMakesMove);
```
.

***

### C. Уравнение с повторной суммой цифр

Задача в терминах решения :
- Найти все $x \ge 1$, удовлетворяющие $x + S(x) + S(S(x)) + \dots + S^{(k)}(x) = n$, где $S$ — сумма цифр и $S^{(i)}$ — $i$-кратное применение $S$.

Идея :
- Значение суммы цифр стремительно падает к однозначным числам 1..9, причём для $n \le 10^{12}$ достаточно рассмотреть $S(x) \in [1, 9 \cdot 12]$ в грубой оценке, потому что максимум суммы цифр достигается при 12 девятках.
- Переберём возможные $s = S(x)$, восстановим по уравнению $x = n - s - S(s) - S(S(s)) - \dots$ учитывая, что хвост быстро стабилизируется $S(t) = t$ и тогда остаток хвоста считается формулой, и в конце проверим, что $S(x) = s$ и $x \ge 1$.

Корректность :
- Полный перебор по $s$ корректен, так как каждое решение имеет конкретное $s = S(x)$, а диапазон для $s$ покрывает все возможные значения суммы цифр $x \le n$ в заданных ограничениях.
- Учет стабилизации $S(t) = t$ даёт точный расчёт хвоста $(k - i + 1) \cdot t$, без потерь.

Реализация :
- Рекурсивная или итеративная функция суммы цифр, безопасная по глубине для 12 разрядов в Python и константная в C++.
- Для каждого $s \in S$ вычисляется кандидат $x$, затем проверка предиката и накопление решений, после чего сортировка и вывод.

Сложность :
- Время ~ $O(108 \cdot k)$ на инстанс плюс стоимость вычислений суммы цифр для хвоста, практически константно для заданных ограничений, память $O(ans)$.

Подводные камни :
- Обязательно проверять $x \ge 1$ и точное равенство $S(x) = s$, иначе в список попадут ложные кандидаты.
- Хвост нужно уметь досчитать формулой, когда $S(t) = t$, иначе будет лишняя работа и возможные ошибки в индексации шагов.

Фрагмент проверки кандидата :
```cpp
int last = sumX, x = n - sumX;
for (int i = 2; i <= k; i++) {
    int cur = sumDigits(last);
    if (cur == last) { x -= (k - i + 1) * last; break; }
    x -= cur; last = cur;
}
if (x >= 1 && sumDigits(x) == sumX) answ.push_back(x);
```
.

***

### D. Максимум суммы OR/AND по нулям и единицам

Постановка в терминах решения: заданы количества нулей $n_0$, единиц $n_1$ и число операций OR $n_{\text{OR}}$ между соседними элементами в строющейся бинарной последовательности длины $n_0+n_1$, остальные из $n_0+n_1-1$ операций являются AND; требуется расставить порядок элементов и операций, максимизируя сумму значений по всем бинарным операциям на соседних парах.
Формат ввода в решениях: несколько тестов, для каждого три целых $n_0,n_1,n_{\text{OR}}$, а ответом является искомый максимум значения функции «сумма результатов OR/AND по ребрам соседства».

Идея: сводим задачу к конструированию последовательности блоками с фиксированным приоритетом, так чтобы каждый поставленный блок «конвертировал» выделенные операции OR/AND в гарантированные единичные вклады, минимизируя штрафы на стыках блоков.
Ключевая формула для баланса операций: $n_{\text{AND}} = n_0 + n_1 - 1 - n_{\text{OR}}$, так как между $n_0+n_1$ элементами всего $n_0+n_1-1$ бинарных связок, из которых $n_{\text{OR}}$ — OR и остальные — AND.

Приоритет блоков:  
- Чередующиеся пары [0 1] с OR: сначала один блок [0 1] даёт +1, затем донабираем ещё пары, каждая приносит +2 благодаря двум OR на подотрезке 0–1–0–1.
- Группа подряд идущих единиц с AND: даёт +cnt, но если слева был 0, то первый стык «съедает» единицу вклада как штраф −1 из-за вынужденного соединения блоков.
- Группа единиц с OR: приносит +cnt, но если это самый первый блок (пустая последовательность слева), то первый стык отсутствует и возникает штраф −1.
- Группа нулей с OR: вклад либо 0, либо +1 за один переход 1→0, если слева уже была единица, после чего дальнейшие OR внутри нулей дают 0.

Корректность: каждый блок гарантированно «монетизирует» выделенные операции в единичные вклады в пределах локальной структуры 0/1, а штрафы учитывают единственный «непроизводительный» стык при разрыве шаблона на границе блоков.
Жадный порядок блоков оптимален, так как сначала расходуются самые доходные в пересчёте на операцию конфигурации OR между 0 и 1, затем максимально «упаковывается» ресурс AND внутри единиц, и только потом расходуются OR на остатках, где их маржинальная полезность минимальна.

Обработка крайних случаев:  
- Если $n_0=0$, ответ равен $n_1-1$, так как любые OR/AND между единицами дают 1 и число операций фиксировано.
- Если $n_1=0$, ответ 0, поскольку любые OR/AND на нулях равны 0.

Реализация:  
- Вычислить $n_{\text{AND}} = n_0 + n_1 - 1 - n_{\text{OR}}$ и завести счётчик ответа, а также состояние last (последний символ) и len (текущая длина) для корректного учёта стыковых штрафов/бонусов.
- Последовательно применять блоки: один [0 1] с OR, затем партии пар [0 1] с двумя OR на пару, затем вытянуть максимум единиц через AND, затем — через OR, и в конце использовать оставшиеся нули под OR, каждый раз ограничивая cnt минимальным из доступных ресурсов.

Сложность: решения работают за $O(1)$ на тест, так как выполняют лишь конечное число арифметических операций и минимумов без перебора по позициям, что подтверждается замерами в заголовках файлов решений.
Память также $O(1)$, используются только несколько счётчиков и константные временные переменные состояния без массивов.

Подводные камни:  
- Не забыть про стыковой штраф при начале блока единиц после нуля для AND и при старте всей последовательности для OR по единицам, иначе ответ будет завышен на 1.
- В блоке нулей под OR вклад не накапливается линейно: засчитывается лишь один переход 1→0 при наличии единицы слева, дальнейшие OR внутри нулей дают 0.

Полезные фрагменты:  
```cpp
// баланс операций
int nAND = n0 + n1 - 1 - nOR;

// стартовая пара [0,1] с OR
if (n0 > 0 && n1 > 0 && nOR >= 1) {
    n0--, n1--, nOR--;
    answ++; len += 2; last = 1;
}

// добор пар [0,1] с двумя OR на пару
if (int cnt = min({n0, n1, nOR / 2}); cnt > 0) {
    n0 -= cnt; n1 -= cnt; nOR -= 2 * cnt;
    answ += 2 * cnt; len += 2 * cnt; last = 1;
}

// единицы под AND с учётом штрафа, если last == 0
if (int cnt = min(n1, nAND); cnt > 0) {
    n1 -= cnt; nAND -= cnt; answ += cnt;
    if (last == 0) answ--;
    last = 1; len += cnt;
}
```
Фрагмент отражает ключевые блоки и корректный учёт штрафов/бонусов на границах последовательности, как реализовано в предоставленных решениях.

***

### E. Делители и минимальная система счисления для «EF»

Постановка в терминах решения :
- Искомое значение «EF» в системе счисления с основанием base имеет десятичное значение $14 \cdot base + 15$, и по условию оно должно делить $n$.

Идея :
- Перебрать все делители $x$ числа $n$, для каждого положить $14 \cdot base + 15 = x$, откуда $base = \frac{x - 15}{14}$, проверить целочисленность, условие $base \ge 16$ и выбрать минимальный base, если он существует, иначе ответ $-1$.

Корректность :
- Любое валидное «EF» обязано быть делителем $n$ и единственным образом задаёт base, поэтому перебор делителей покрывает все варианты и даёт точный минимум.

Реализация :
- Стандартная факторизация за $O(\sqrt{n})$ с разложением на нижнюю/верхнюю половины, дающая отсортированный список делителей без дополнительных затрат.
- Линейный проход по делителям, проверка равенства $14 \cdot base + 15 = x$ и порога $base \ge 16$, затем печать минимума либо $-1$.

Сложность :
- Время $O(\sqrt{n})$ на факторизацию плюс $O(\tau(n))$ на проверки, память $O(\tau(n))$ для хранения делителей, где $\tau(n)$ — число делителей.

Подводные камни :
- Деление должно быть целочисленным, проверьте равенство обратной подстановкой, а не только по целочисленному делению, чтобы исключить некорректные остатки.
- Не забудьте нижнюю границу $base \ge 16$ по условию систем счисления с цифрой F.

Фрагмент проверки :
```cpp
int base = (x - 15) / 14;
if (base >= 16 && 14 * base + 15 == x) minBase = min(minBase, base);
```
.

***

### F. Периметр, делимость на катет и Пифагор

Постановка в терминах решения: дан фиксированный катет $a$, требуется посчитать число уникальных прямоугольных треугольников с целочисленными сторонами $(a,b,c)$, где $a^2 + b^2 = c^2$ и периметр $a+b+c$ делится на один из катетов, то есть либо на $a$, либо на $b$.
Вывод — количество различных троек $(a,b,c)$ с упорядочиванием по катетам так, чтобы исключить дубли вида $(a,b,c)$ и $(b,a,c)$, после нормализации тройки в виде $(\min(a,b), \max(a,b), c)$ и дальнейшего удаления повторов.

Идея: развернём условие делимости для двух случаев и сведём поиск к перебору делителей числа $a$ с последующей проверкой кандидатных троек по теореме Пифагора.
Базовая факторизация следует из тождества Пифагора $a^2 = c^2 - b^2 = (c-b)(c+b)$, которое удобно комбинируется с линейными соотношениями от условий делимости периметра.

Случай 1: $a+b+c$ делится на $a$: из $a \mid (a+b+c)$ имеем $a \mid (b+c)$, то есть $b+c = k a$ для некоторого $k \ge 1$, откуда из $a^2 = (c-b)(c+b)$ следует $a^2 = (c-b)\cdot k a$ и, следовательно, $c-b = a/k$ при $k \mid a$.
Решение для фиксированного $k \mid a$: $q=a/k; c = (k a + q)/2; b = c - q$ с последующей проверкой $c^2 = a^2 + b^2$ и неотрицательности, что задаёт корректные кандидатные тройки.

Случай 2: $a+b+c$ делится на $b$: из $b \mid (a+c)$ пусть $a + c = k b$, тогда из $b^2 = (c-a)(c+a)$ получаем $b = (c-a)k$, и, устраняя $c$ через $c = k b - a$, выводим $b = \frac{2k}{k^2 - 1} a$.
Далее учитываем $\gcd(2k, k^2-1) \in [1,2]$ и требуем, чтобы знаменатель после сокращения делил $a$, что сводит перебор к делителям $d \mid a$ и двум подслучаям для $k$: нечётные $k=2t-1$ с уравнением $2t(t-1)=d$ и чётные $k=2t$ с уравнением $4t^2-1=d$ и проверкой целых $t$ через дискриминант/квадратичные корни.

Корректность: обе ветки полностью параметризуют решения требуемого ограничения «периметр делится на катет»; в первом случае пары делителей $(k, a/k)$ прямо задают $(c-b, c+b)$, а во втором случае параметр $k$ однозначно восстанавливается из уравнений на $t$ при фиксированном делителе $d$ числа $a$.
Нормализация троек переставляет катеты по неубыванию и последующая сортировка с уникализацией исключает дубликаты, что делает итоговый счёт корректным относительно перестановки $a$ и $b$.

Реализация:
- Перебрать все делители $a$ за $O(\sqrt{a})$, для каждого делителя обработать случай 1 по формулам $\;q=a/k,\; c=(k a + q)/2,\; b=c-q$, проверив Пифагора.
- Для случая 2 перебрать те же делители $$d$$ и попытаться восстановить целые $t$ в ветках $2t(t-1)=d$ и $4t^2-1=d$ через квадратные корни/дискриминант, после чего построить $k$, затем $(b,c)$ и проверить условие Пифагора и положительность.

Сложность: факторизация по делителям занимает $O(\sqrt{a})$, каждая проверка кандидата — $O(1)$, суммарно решение работает быстро и укладывается в жёсткие лимиты как в реализации на C++, так и на Python по приведённым замерам.
Память — $O(ans)$ на хранение найденных троек до этапа сортировки и удаления повторов, где используется стандартная сортировка и unique.

Подводные камни:
- В C++ при больших входах нужен тип __int128 для промежуточной арифметики, иначе при вычислении $c^2$ и подобных выражений возможны переполнения и неверные ответы, тогда как в Python большие целые поддерживаются нативно.
- Важно нормализовать $(a,b,c)$ перестановкой катетов и удалить дубликаты после глобальной сортировки, иначе один и тот же треугольник засчитается несколько раз.

Полезные фрагменты:
```cpp
// Случай 1: k | a
int q = a / k;
int c = (k * a + q) / 2;
int b = c - q;
if (b >= 1 && c >= 1 && c * c == b * b + a * a) add(a, b, c);

// Случай 2: из делителя d | a восстановить t и k, затем b, c
// Нечётные k = 2t - 1: 2t(t-1) = d; Чётные k = 2t: 4t^2 - 1 = d
int b = k * a / d;          // или (2*k*a)/d для чётной ветки
int c = k * b - a;
if (b >= 1 && c >= 1 && c * c == b * b + a * a) add(a, b, c);

// Нормализация и уникализация
for (auto& [x, y, z] : ans) if (x > y) swap(x, y);
sort(ans.begin(), ans.end());
ans.erase(unique(ans.begin(), ans.end()), ans.end());
```
Фрагменты correspondируют логике кода и отражают обе ветки с последующей нормализацией и удалением повторов.

***

### H. Две лягушки на круге, синхронные и одиночные прыжки

Модель движения :
- Лягушки сидят на круге из $n$ позиций, стартуют из $a$ и $b$, возможны одиночные шаги (вперёд/назад для каждой) со временами $t_1, t_2, t_3, t_4$, а также синхронные шаги навстречу со временами $t_5, t_6$ для разных направлений дуг.
- Ключевое наблюдение: «одновременно» они реально могут двигаться только через операции с временами $t_5$ или $t_6$, все остальные — это по очереди, и суммарное время определяется минимумом «два одиночных шага самой быстрой» и «один синхронный шаг».

Идея :
- Пусть расстояние по выбранной дуге равно $dist$, тогда за шаг «уменьшения расстояния на 2» стоимость равна $\min(2 \cdot \min(timeA, timeB), timeAB)$, где timeAB — время синхронного шага по соответствующей дуге, а timeA/timeB — времена одиночных шагов лягушек по этой дуге в сторону друг друга.
- Пока $dist \ge 2$ платим блоками по 2, при $dist = 1$ платим $\min(timeA, timeB)$ за последний одиночный шаг, а ещё рассматриваем «выгодный бэкстеп»: иногда выгодно сначала увеличить расстояние на 1, заплатив $\min(timeA^{-1}, timeB^{-1})$, а потом идти штатно.

Алгоритм :
- Рассчитать дуги AB и BA как направленные расстояния на круге, для каждой дуги посчитать два варианта: «сразу сближаться» и «шаг назад, затем сближаться», взять минимум из четырёх сценариев.
- Подсчёт стоимости по фиксированному $dist$: 
$cost(dist) = \left\lfloor \frac{dist}{2} \right\rfloor \cdot \min\big(timeAB,\ 2 \cdot \min(timeA, timeB)\big) + \big(dist \bmod 2\big) \cdot \min(timeA, timeB)$.

Корректность :
- Полный перебор двух дуг и двух режимов (прямо/с бэкстепом) покрывает все оптимальные стратегии благодаря аддитивности стоимости укорочения дистанции и независимости выбора «где сделать бэкстеп» по структуре дуги.
- Формула стоимости по блокам «минус 2» корректно учитывает «или синхронно, или два одиночных шага самой быстрой» как доминирующие способы сокращать расстояние.

Сложность :
- Время и память — $O(1)$, так как вычисляется фиксированная формула по четырём сценариям.

Подводные камни и примечания к Python :
- Правильно сопоставьте какие времена соответствуют какой дуге: AB использует набор $(t_1, t_4, t_2, t_3, t_5)$, BA — $(t_2, t_3, t_1, t_4, t_6)$ согласно направлениям.
- В Python нет перегрузки, поэтому функции должны иметь разные имена, и используйте быстрый ввод/вывод, если обрабатывается много тестов.

Полезные фрагменты :
```cpp
int per2 = min<int>(timeMeet, 2 * min<int>(timeA, timeB));
int ans = (dist / 2) * per2 + (dist % 2 ? min<int>(timeA, timeB) : 0);
int withBack = solve(dist + 1, timeA, timeB, timeMeet) + min<int>(timeAinv, timeBinv);
return min(ans, withBack);
```
.

***

### I. Интерактив: делимость через «запрос 1» и фильтрация кандидатов

Интерактивная механика (по коду и комментариям) :
- Всего 300 запросов, что совпадает с числом простых до 1986, и это не случайно обыгрывается в комментарии.
- Замысел: первым делом задаём запрос «1», чтобы гарантировать, что «1» будет среди напечатанных НОД, и тогда для любого простого $p$ значение $\gcd(x, p) \in \{1, p\}$ позволит однозначно понять делимость $x$ на $p$ по ответу жюри, сообщающему «был ли этот НОД уже напечатан» в виде 1/0 с учетом того, что 1 уже точно был.

Идея :
- Вести массив кандидатов $\{1,2,\dots,1986\}$, на каждом шаге брать $p$ как второй элемент массива (фактически возрастающий перебор), спрашивать про $p$ и фильтровать кандидатов по делимости на $p$ согласно ответу, пока не останется один элемент.

Корректность :
- После запроса «1» ответы 0/1 на простых $p$ точно кодируют факт делимости $x$ на $p$, что обеспечивает корректную фильтрацию множества кандидатов вплоть до единственного элемента.

Реализация и интерактивные детали :
- На каждый запрос печатается «? v», считывается ответ, а при сообщении решения — «! x», не забывайте flush в Python и endl в C++.
- Для устойчивости по ограничениям можно перебирать последовательность «простые/их степени», однако описанная стратегия уже укладывается в лимит и проходит по времени.

Сложность :
- Количество запросов на один тест ограничено сверху небольшой константой, в пределах 300, фильтрация списка — линейная, что укладывается в лимит.

Подводные камни :
- Не забыть сделать первый запрос «1», иначе двузначность ответов по $\gcd(x,p)$ нарушит логику фильтрации.
- Корректно поддерживать массив кандидатов in-place или пересборкой нового списка, чтобы не допустить ошибок инвариантов.

Фрагмент фильтрации :
```cpp
int p = candidates;
int res = ask(p);
int len = 0;
for (int v : candidates)
    if ((v % p == 0) == (res == 0))
        candidates[len++] = v;
candidates.resize(len);
```
.

***

### M. Добивание остатка по модулю 60 двусторонними добавлениями (BFS)

Постановка в терминах решения :
- Дана строка из {A..F} как шестнадцатеричные цифры 10..15, разрешено добавлять буквы в начало или конец, цель — добиться делимости на 60, при этом среди кратчайших решений вывести лексикографически минимальную «сводку добавлений» в порядке A..F либо «OK», если добавления не нужны.

Идея :
- Работать в пространстве состояний «длина, остаток по модулю 60», так как переходы при добавлении слева/справа вычисляются формулами на остатки и длину, а ответа требуется немного, потому что целевой остаток 0 «близок» в цикле по 60.
- Запустить BFS от стартового состояния, на каждом шаге генерировать 12 переходов: 6 букв в конец и 6 букв в начало, отслеживая лучший по длине уровень, и на нём собирать все варианты подсчёта букв для лексикографического минимума.

Переходы остатков :
- Добавление справа цифры $d \in \{10..15\}$ : $rem' = (rem \cdot 16 + d) \bmod 60$.
- Добавление слева: $rem' = (d \cdot 16^{len} + rem) \bmod 60$ с вычислением $16^{len} \bmod 60$ быстрым возведением в степень.

Корректность :
- BFS по состояниям (len, rem) минимизирует длину добавлений, а сбор всех ответов на минимальной длине и выбор минимума по строке «сводки» даёт ровно требуемую спецификацию задачи.
- Формулы переходов непосредственно следуют из арифметики позиционных систем при конкатенации слева/справа.

Реализация :
- Функции convert(s) для получения начального (len, rem), digit для перевода A..F в 10..15, modPow/pow для вычислений, очередь состояний хранит также массив счётчиков по 6 буквам для последующего формирования ответа.
- При достижении rem=0 обновляется лучшая длина и копится строка arrToStr(cnt), после завершения берётся минимум; пустой набор преобразуется в «OK».

Сложность :
- Состояний не более «несколько уровней» до достижения rem=0, каждый уровень порождает до 12 переходов, на практике очень быстро находя минимальную длину, память пропорциональна числу посещённых состояний и собранных ответов на лучшем уровне.

Подводные камни и примечания к Python :
- В Python обязательно копировать список счётчиков при enqueuing, чтобы избежать aliasing между путями, иначе ответы испортятся из-за общей мутабельности.
- Важно отсечь обработку состояний с длиной ≥ текущего лучшего ответа, чтобы не раздувать поиск за пределы оптимального уровня.

Фрагменты формул :
- Переходы:
```python
newRemRight = (rem * 16 + d) % 60
newRemLeft  = (pow(16, length, 60) * d + rem) % 60
```
.
- Формирование ответа:
```python
res = ''.join(chr(ord('A') + i) * cnt[i] for i in range(6))
print(res if res else "OK")
```
.

***

### Приложение: замеры, модули, и детали реализации из решений

- Указанные решения прошли с вердиктом OK с характерными лимитами времени/памяти: A: 0.843 c / 4 MB, B: 0.039 c / 2 MB (C++), 0.518 c / 114 MB (Python), C: 0.005 c / 2 MB (C++), 0.130 c / 111 MB (Python), E: 0.013 c / 2 MB (C++), 0.068 c / 105 MB (Python), H: 0.059 c / 2 MB (C++), 0.400 c / 120 MB (Python), I: 0.030 c / 2 MB (C++), 0.173 c / 110 MB (Python), M: 0.006 c / 2.4 MB (C++), 0.088 c / 111 MB (Python), что соответствует описанной сложности и выбранным структурам данных.
- Для задачи A используется модуль $998244353$, модульная арифметика реализована стандартными степенями и обратными элементами через возведение в степень $y^{mod-2}$ по малой теореме Ферма, деление выполняется как умножение на обратный элемент.
- Мелкие, но практичные оптимизации: предвычисление таблиц переходов (A), аккуратная сортировка и ранние возвраты по крайним случаям (B), досчёт стационарного хвоста суммы цифр формулой (C), $O(\sqrt{n})$ факторизация с двумя половинами делителей (E), ровно четыре сценария для минимума по дугам и бэкстепу (H), обязательный «? 1» в интерактиве (I), срез поиска по лучшей длине и лексикографический минимум по агрегированным буквам (M).