### Содержание
- A — матожидание длины максимальной римской подстроки
- B — игра с тремя кучками и инверсиями букв
- C — уравнение с повторной суммой цифр
- E — делители и минимальная система счисления для EF
- H — две лягушки на круге, синхронные и одиночные прыжки
- I — интерактив: фильтрация кандидатов делимостью, хитрость с «1»
- M — добивание остатка по модулю 60 двусторонними добавлениями (BFS)

### Как читать
В каждой секции: идея, корректность/интуиция, реализация, сложность, ошибки и примечания к языку (если есть), чтобы быстро сопоставить со своим подходом и закрыть пробелы.

***

### A. Матожидание длины максимальной римской подстроки

Идея :
- По определению математического ожидания: $\mathbb{E} = \sum_{k=1}^{15} k \cdot \frac{f(n,k)}{7^n}$, где $f(n,k)$ — число строк длины $n$ над алфавитом {M,D,C,L,X,V,I}, у которых длина максимальной римской подстроки ровно $k$.
- Сведём к динамике по префиксам: храним римский суффикс строки как «последнее римское число» и максимум длины римской подстроки на этом префиксе.

Модель ДП :
- Состояние: $dp[len][last][k]$ — число строк длины len, оканчивающихся римским числом last (код от 0 до 3999), с текущим максимумом длины римской подстроки $k$.
- Переход: добавляем символ c {M,D,C,L,X,V,I}, пересчитываем максимальный римский суффикс в строке (last + c), его длину L и делаем $dp[len+1][newLast][\max(k,L)]{+}{=}\ dp[len][last][k]$.
- Затем$f(n,k) = \sum_{last=1}^{3999} dp[n][last][k]$и ответ равен$\sum_{k=1}^{15} k \cdot f(n,k) / 7^n$по модулю$998244353$с использованием обратного элемента для деления.

Подготовка данных :
- Предварительно строим все римские записи 1..3999 и ассоциируем мапой строку → число, что позволяет проверять «максимальный римский суффикс» у строки за счёт перебора суффиксов и поиска в словаре.
- Предподсчитываем переходы nextRoman[prevNumber][ic] для каждой пары «текущее римское число, добавляемая буква», что критично для скорости основной ДП.

Корректность :
- Римский суффикс после добавления символа единственно определяется как самый длинный суффикс, являющийся корректной римской записью, что и моделирует переход nextRoman.
- Максимум длины римской подстроки поддерживается монотонно как$\max$от предыдущего значения и длины нового римского суффикса, что эквивалентно определению максимальной римской подстроки в префиксах.
- Линейность матожидания с подсчётом количества конфигураций даёт формулу ожидания через$f(n,k)$и равномерное число строк$7^n$.

Реализация и детали модуля :
- Используется двуслойная ДП на last×k для экономии памяти, модульные операции add/mul/pow/inv/div с модом$998244353$.
- Начальное состояние dp = 1, где «0» — пустая римская строка, длиной 0.
- В конце суммируем по last и k, затем делим на$7^n$с помощью обратного по модулю.

Сложность :
- Предподсчёт переходов:$O(4000 \cdot 7 \cdot L)$, где L — длина проверяемых суффиксов (маленькая константа в среднем).
- Основная ДП:$O(n \cdot 4000 \cdot 7 \cdot 16)$, оценочно порядка$7.5 \cdot 10^8$элементарных операций в худшем случае, что требует агрессивной оптимизации (Ofast, unroll-loops, компактные типы).

Подводные камни :
- Корректность таблицы всех римских чисел 1..3999 и строгая каноничность записи важны для уникальности переходов.
- Нельзя забывать, что last=0 соответствует пустому суффиксу, и переходы из него также допустимы.
- Деление по модулю выполняется умножением на обратный элемент$7^{-n}$, прямое деление недопустимо.

Полезные фрагменты :
- Переход при добавлении символа:
```cpp
int nextNumber = nextRoman[prevNumber][ic];
int L = (int)roman[nextNumber].size();
int nextAnswer = max(prevAnswer, L);
modAddTo(dpNext[nextNumber][nextAnswer], dpCurr[prevNumber][prevAnswer]);
```
.

***

### B. Игра с тремя кучками и инверсиями букв

Постановка в терминах решения :
- Есть три кучки с буквами на вершине, на каждом ходе выбираются две кучки, их размеры уменьшаются на 1, а буквы инвертируются функцией opposite (A↔B).
- Возвращается идентификатор победителя при оптимальной игре, где ход невозможен означает поражение текущего игрока.

Идея и инварианты :
- Если на столе две одинаковые и одна отличная буквы, то ход единственный: нужно тронуть те две, что совпадают, после чего все три станут одинаковыми, и игра переходит в «симметрический» режим.
- В режиме «все три вершины одинаковы» активный игрок волен выбирать любые две кучки, а затем у оппонента снова будет единственный ответ, то есть инициатор контролирует «пары» ходов и должен завести позицию в проигрыш для соперника.

Полный разбор случаев (после доведения букв к одинаковым) :
- Если все три размера чётные, текущий игрок проигрывает, так как каждое «сдвоенное» уменьшение на 2 приводит в позицию того же типа и паритет не даёт шанса сломать симметрию в свою пользу.
- Отсортируем размеры по возрастанию и разберём крайние случаи пустот: если две кучки пусты, то ход невозможен и текущий игрок немедленно проигрывает.
- Если ровно одна пустая кучка, то дальнейшие ходы однозначны и исход определяется чётностью второй кучки: чётная — проигрыш текущего, нечётная — выигрыш текущего.
- Если среди трёх хотя бы две нечётные, у текущего игрока есть выигрышная стратегия, выбирая на каждом шаге две нечётные и сохраняя контроль.
- Если одна кучка нечётная, две чётные, то выигрыш возможен тогда и только тогда, когда сумма чётных не меньше нечётной: выбирая каждый раз пару «чётная+нечётная», текущий игрок доводит до тупика соперника, иначе проигрывает.

Корректность и интуиция :
- Приведение букв к одинаковым фиксирует «структуру выбора» и позволяет анализировать только паритеты и нули, так как буквы потом зеркально следуют друг за другом.
- Случай с одной нечётной редуцируется к ресурсу «масса чётных против размера нечётной», что даёт точное условие выигрыша.

Реализация :
- Сначала применяем единственный принудительный ход, когда есть «две одинаковые, одна другая», после чего все три вершины совпадают по букве.
- Дальше пошагово применяем описанный разбор по паритетам и нулям с сортировкой размеров и возвратом победителя.

Сложность :
- Время и память —$O(1)$, только константные вычисления и сравнения.

Подводные камни :
- Не забыть выполнить принудительный ход с «двумя одинаковыми» перед разбором, иначе логика по паритетам станет неверной.
- Аккуратно обработать нулевые кучки и сортировку, чтобы не пропустить граничные случаи.

Полезные фрагменты :
```cpp
if (n1 % 2 == 0 && n2 % 2 == 0 && n3 % 2 == 0) return 1 - whoMakesMove;
if (n1 > n2) swap(n1, n2);
if (n1 > n3) swap(n1, n3);
if (n2 > n3) swap(n2, n3);
if (n1 == 0 && n2 == 0) return 1 - whoMakesMove;
if (n1 == 0) return (n2 % 2 == 0) ? (1 - whoMakesMove) : whoMakesMove;
if ((n1 % 2) + (n2 % 2) + (n3 % 2) >= 2) return whoMakesMove;
int odd = (n1 % 2 ? n1 : (n2 % 2 ? n2 : n3));
int evenSum = n1 + n2 + n3 - odd;
return (evenSum >= odd) ? whoMakesMove : (1 - whoMakesMove);
```
.

***

### C. Уравнение с повторной суммой цифр

Задача в терминах решения :
- Найти все$x \ge 1$, удовлетворяющие$x + S(x) + S(S(x)) + \dots + S^{(k)}(x) = n$, где$S$— сумма цифр и$S^{(i)}$—$i$-кратное применение$S$.

Идея :
- Значение суммы цифр стремительно падает к однозначным числам 1..9, причём для$n \le 10^{12}$достаточно рассмотреть$S(x) \in [1, 9 \cdot 12]$в грубой оценке, потому что максимум суммы цифр достигается при 12 девятках.
- Переберём возможные$s = S(x)$, восстановим по уравнению$x = n - s - S(s) - S(S(s)) - \dots$учитывая, что хвост быстро стабилизируется$S(t) = t$и тогда остаток хвоста считается формулой, и в конце проверим, что$S(x) = s$и$x \ge 1$.

Корректность :
- Полный перебор по$s$корректен, так как каждое решение имеет конкретное$s = S(x)$, а диапазон для$s$покрывает все возможные значения суммы цифр$x \le n$в заданных ограничениях.
- Учет стабилизации$S(t) = t$даёт точный расчёт хвоста$(k - i + 1) \cdot t$, без потерь.

Реализация :
- Рекурсивная или итеративная функция суммы цифр, безопасная по глубине для 12 разрядов в Python и константная в C++.
- Для каждого$s \in $вычисляется кандидат$x$, затем проверка предиката и накопление решений, после чего сортировка и вывод.

Сложность :
- Время ~$O(108 \cdot k)$на инстанс плюс стоимость вычислений суммы цифр для хвоста, практически константно для заданных ограничений, память$O(\#ans)$.

Подводные камни :
- Обязательно проверять$x \ge 1$и точное равенство$S(x) = s$, иначе в список попадут ложные кандидаты.
- Хвост нужно уметь досчитать формулой, когда$S(t) = t$, иначе будет лишняя работа и возможные ошибки в индексации шагов.

Фрагмент проверки кандидата :
```cpp
int last = sumX, x = n - sumX;
for (int i = 2; i <= k; i++) {
    int cur = sumDigits(last);
    if (cur == last) { x -= (k - i + 1) * last; break; }
    x -= cur; last = cur;
}
if (x >= 1 && sumDigits(x) == sumX) answ.push_back(x);
```
.

***

### E. Делители и минимальная система счисления для «EF»

Постановка в терминах решения :
- Искомое значение «EF» в системе счисления с основанием base имеет десятичное значение$14 \cdot base + 15$, и по условию оно должно делить$n$.

Идея :
- Перебрать все делители$x$числа$n$, для каждого положить$14 \cdot base + 15 = x$, откуда$base = \frac{x - 15}{14}$, проверить целочисленность, условие$base \ge 16$и выбрать минимальный base, если он существует, иначе ответ$-1$.

Корректность :
- Любое валидное «EF» обязано быть делителем$n$и единственным образом задаёт base, поэтому перебор делителей покрывает все варианты и даёт точный минимум.

Реализация :
- Стандартная факторизация за$O(\sqrt{n})$с разложением на нижнюю/верхнюю половины, дающая отсортированный список делителей без дополнительных затрат.
- Линейный проход по делителям, проверка равенства$14 \cdot base + 15 = x$и порога$base \ge 16$, затем печать минимума либо$-1$.

Сложность :
- Время$O(\sqrt{n})$на факторизацию плюс$O(\tau(n))$на проверки, память$O(\tau(n))$для хранения делителей, где$\tau(n)$— число делителей.

Подводные камни :
- Деление должно быть целочисленным, проверьте равенство обратной подстановкой, а не только по целочисленному делению, чтобы исключить некорректные остатки.
- Не забудьте нижнюю границу$base \ge 16$по условию систем счисления с цифрой F.

Фрагмент проверки :
```cpp
int base = (x - 15) / 14;
if (base >= 16 && 14 * base + 15 == x) minBase = min(minBase, base);
```
.

***

### H. Две лягушки на круге, синхронные и одиночные прыжки

Модель движения :
- Лягушки сидят на круге из$n$позиций, стартуют из$a$и$b$, возможны одиночные шаги (вперёд/назад для каждой) со временами$t_1, t_2, t_3, t_4$, а также синхронные шаги навстречу со временами$t_5, t_6$для разных направлений дуг.
- Ключевое наблюдение: «одновременно» они реально могут двигаться только через операции с временами$t_5$или$t_6$, все остальные — это по очереди, и суммарное время определяется минимумом «два одиночных шага самой быстрой» и «один синхронный шаг».

Идея :
- Пусть расстояние по выбранной дуге равно$dist$, тогда за шаг «уменьшения расстояния на 2» стоимость равна$\min(2 \cdot \min(timeA, timeB), timeAB)$, где timeAB — время синхронного шага по соответствующей дуге, а timeA/timeB — времена одиночных шагов лягушек по этой дуге в сторону друг друга.
- Пока$dist \ge 2$платим блоками по 2, при$dist = 1$платим$\min(timeA, timeB)$за последний одиночный шаг, а ещё рассматриваем «выгодный бэкстеп»: иногда выгодно сначала увеличить расстояние на 1, заплатив$\min(timeA^{-1}, timeB^{-1})$, а потом идти штатно.

Алгоритм :
- Рассчитать дуги AB и BA как направленные расстояния на круге, для каждой дуги посчитать два варианта: «сразу сближаться» и «шаг назад, затем сближаться», взять минимум из четырёх сценариев.
- Подсчёт стоимости по фиксированному$dist$: 
$
cost(dist) = \left\lfloor \frac{dist}{2} \right\rfloor \cdot \min\big(timeAB,\ 2 \cdot \min(timeA, timeB)\big) + \big(dist \bmod 2\big) \cdot \min(timeA, timeB)
$
.

Корректность :
- Полный перебор двух дуг и двух режимов (прямо/с бэкстепом) покрывает все оптимальные стратегии благодаря аддитивности стоимости укорочения дистанции и независимости выбора «где сделать бэкстеп» по структуре дуги.
- Формула стоимости по блокам «минус 2» корректно учитывает «или синхронно, или два одиночных шага самой быстрой» как доминирующие способы сокращать расстояние.

Сложность :
- Время и память —$O(1)$, так как вычисляется фиксированная формула по четырём сценариям.

Подводные камни и примечания к Python :
- Правильно сопоставьте какие времена соответствуют какой дуге: AB использует набор$(t_1, t_4, t_2, t_3, t_5)$, BA —$(t_2, t_3, t_1, t_4, t_6)$согласно направлениям.
- В Python нет перегрузки, поэтому функции должны иметь разные имена, и используйте быстрый ввод/вывод, если обрабатывается много тестов.

Полезные фрагменты :
```cpp
int per2 = min<int>(timeMeet, 2 * min<int>(timeA, timeB));
int ans = (dist / 2) * per2 + (dist % 2 ? min<int>(timeA, timeB) : 0);
int withBack = solve(dist + 1, timeA, timeB, timeMeet) + min<int>(timeAinv, timeBinv);
return min(ans, withBack);
```
.

***

### I. Интерактив: делимость через «запрос 1» и фильтрация кандидатов

Интерактивная механика (по коду и комментариям) :
- Всего 300 запросов, что совпадает с числом простых до 1986, и это не случайно обыгрывается в комментарии.
- Замысел: первым делом задаём запрос «1», чтобы гарантировать, что «1» будет среди напечатанных НОД, и тогда для любого простого$p$значение$\gcd(x, p) \in \{1, p\}$позволит однозначно понять делимость$x$на$p$по ответу жюри, сообщающему «был ли этот НОД уже напечатан» в виде 1/0 с учетом того, что 1 уже точно был.

Идея :
- Вести массив кандидатов$\{1,2,\dots,1986\}$, на каждом шаге брать$p$как второй элемент массива (фактически возрастающий перебор), спрашивать про$p$и фильтровать кандидатов по делимости на$p$согласно ответу, пока не останется один элемент.

Корректность :
- После запроса «1» ответы 0/1 на простых$p$точно кодируют факт делимости$x$на$p$, что обеспечивает корректную фильтрацию множества кандидатов вплоть до единственного элемента.

Реализация и интерактивные детали :
- На каждый запрос печатается «? v», считывается ответ, а при сообщении решения — «! x», не забывайте flush в Python и endl в C++.
- Для устойчивости по ограничениям можно перебирать последовательность «простые/их степени», однако описанная стратегия уже укладывается в лимит и проходит по времени.

Сложность :
- Количество запросов на один тест ограничено сверху небольшой константой, в пределах 300, фильтрация списка — линейная, что укладывается в лимит.

Подводные камни :
- Не забыть сделать первый запрос «1», иначе двузначность ответов по$\gcd(x,p)$нарушит логику фильтрации.
- Корректно поддерживать массив кандидатов in‑place или пересборкой нового списка, чтобы не допустить ошибок инвариантов.

Фрагмент фильтрации :
```cpp
int p = candidates;
int res = ask(p);
int len = 0;
for (int v : candidates)
    if ((v % p == 0) == (res == 0))
        candidates[len++] = v;
candidates.resize(len);
```
.

***

### M. Добивание остатка по модулю 60 двусторонними добавлениями (BFS)

Постановка в терминах решения :
- Дана строка из {A..F} как шестнадцатеричные цифры 10..15, разрешено добавлять буквы в начало или конец, цель — добиться делимости на 60, при этом среди кратчайших решений вывести лексикографически минимальную «сводку добавлений» в порядке A..F либо «OK», если добавления не нужны.

Идея :
- Работать в пространстве состояний «длина, остаток по модулю 60», так как переходы при добавлении слева/справа вычисляются формулами на остатки и длину, а ответа требуется немного, потому что целевой остаток 0 «близок» в цикле по 60.
- Запустить BFS от стартового состояния, на каждом шаге генерировать 12 переходов: 6 букв в конец и 6 букв в начало, отслеживая лучший по длине уровень, и на нём собирать все варианты подсчёта букв для лексикографического минимума.

Переходы остатков :
- Добавление справа цифры$d \in \{10..15\}$:$rem' = (rem \cdot 16 + d) \bmod 60$.
- Добавление слева:$rem' = (d \cdot 16^{len} + rem) \bmod 60$с вычислением$16^{len} \bmod 60$быстрым возведением в степень.

Корректность :
- BFS по состояниям (len, rem) минимизирует длину добавлений, а сбор всех ответов на минимальной длине и выбор минимума по строке «сводки» даёт ровно требуемую спецификацию задачи.
- Формулы переходов непосредственно следуют из арифметики позиционных систем при конкатенации слева/справа.

Реализация :
- Функции convert(s) для получения начального (len, rem), digit для перевода A..F в 10..15, modPow/pow для вычислений, очередь состояний хранит также массив счётчиков по 6 буквам для последующего формирования ответа.
- При достижении rem=0 обновляется лучшая длина и копится строка arrToStr(cnt), после завершения берётся минимум; пустой набор преобразуется в «OK».

Сложность :
- Состояний не более «несколько уровней» до достижения rem=0, каждый уровень порождает до 12 переходов, на практике очень быстро находя минимальную длину, память пропорциональна числу посещённых состояний и собранных ответов на лучшем уровне.

Подводные камни и примечания к Python :
- В Python обязательно копировать список счётчиков при enqueuing, чтобы избежать aliasing между путями, иначе ответы испортятся из-за общей мутабельности.
- Важно отсечь обработку состояний с длиной ≥ текущего лучшего ответа, чтобы не раздувать поиск за пределы оптимального уровня.

Фрагменты формул :
- Переходы:
```python
newRemRight = (rem * 16 + d) % 60
newRemLeft  = (pow(16, length, 60) * d + rem) % 60
```
.
- Формирование ответа:
```python
res = ''.join(chr(ord('A') + i) * cnt[i] for i in range(6))
print(res if res else "OK")
```
.

***

### Приложение: замеры, модули, и детали реализации из решений

- Указанные решения прошли с вердиктом OK с характерными лимитами времени/памяти: A: 0.843 c / 4 MB, B: 0.039 c / 2 MB (C++), 0.518 c / 114 MB (Python), C: 0.005 c / 2 MB (C++), 0.130 c / 111 MB (Python), E: 0.013 c / 2 MB (C++), 0.068 c / 105 MB (Python), H: 0.059 c / 2 MB (C++), 0.400 c / 120 MB (Python), I: 0.030 c / 2 MB (C++), 0.173 c / 110 MB (Python), M: 0.006 c / 2.4 MB (C++), 0.088 c / 111 MB (Python), что соответствует описанной сложности и выбранным структурам данных.
- Для задачи A используется модуль$998244353$, модульная арифметика реализована стандартными степенями и обратными элементами через возведение в степень$y^{mod-2}$по малой теореме Ферма, деление выполняется как умножение на обратный элемент.
- Мелкие, но практичные оптимизации: предвычисление таблиц переходов (A), аккуратная сортировка и ранние возвраты по крайним случаям (B), досчёт стационарного хвоста суммы цифр формулой (C),$O(\sqrt{n})$факторизация с двумя половинами делителей (E), ровно четыре сценария для минимума по дугам и бэкстепу (H), обязательный «? 1» в интерактиве (I), срез поиска по лучшей длине и лексикографический минимум по агрегированным буквам (M).

(https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/69856375/ffe22dfe-ffa3-461d-a3d5-5e7aa1a19db4/paste.txt)