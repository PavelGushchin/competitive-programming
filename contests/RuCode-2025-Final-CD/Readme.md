Готов подробный README‑разбор решений RuCode Final 2025 Division CD по задачам A, B, C, E, H, I, M в стиле редакторских разборов Codeforces, основанный на комментариях и приёмах из предоставленных решений, без потерь важных деталей и с акцентом на идею, корректность, реализацию и подводные камни для тех, кто не смог дорешать на контесте.[1]

### Содержание
- A — матожидание длины максимальной римской подстроки[1]
- B — игра с тремя кучками и инверсиями букв[1]
- C — уравнение с повторной суммой цифр[1]
- E — делители и минимальная система счисления для EF[1]
- H — две лягушки на круге, синхронные и одиночные прыжки[1]
- I — интерактив: фильтрация кандидатов делимостью, хитрость с «1»[1]
- M — добивание остатка по модулю 60 двусторонними добавлениями (BFS)[1]

### Как читать
В каждой секции: идея, корректность/интуиция, реализация, сложность, ошибки и примечания к языку (если есть), чтобы быстро сопоставить со своим подходом и закрыть пробелы.[1]

***

### A. Матожидание длины максимальной римской подстроки

Идея :[1]
- По определению математического ожидания: $$ \mathbb{E} = \sum_{k=1}^{15} k \cdot \frac{f(n,k)}{7^n} $$, где $$ f(n,k) $$ — число строк длины $$ n $$ над алфавитом {M,D,C,L,X,V,I}, у которых длина максимальной римской подстроки ровно $$ k $$.[1]
- Сведём к динамике по префиксам: храним римский суффикс строки как «последнее римское число» и максимум длины римской подстроки на этом префиксе.[1]

Модель ДП :[1]
- Состояние: $$ dp[len][last][k] $$ — число строк длины len, оканчивающихся римским числом last (код от 0 до 3999), с текущим максимумом длины римской подстроки $$ k \in  $$.[1]
- Переход: добавляем символ c ∈ {M,D,C,L,X,V,I}, пересчитываем максимальный римский суффикс в строке (last + c), его длину L и делаем $$ dp[len+1][newLast][\max(k,L)]{+}{=}\ dp[len][last][k] $$.[1]
- Затем $$ f(n,k) = \sum_{last=1}^{3999} dp[n][last][k] $$ и ответ равен $$ \sum_{k=1}^{15} k \cdot f(n,k) / 7^n $$ по модулю $$ 998244353 $$ с использованием обратного элемента для деления.[1]

Подготовка данных :[1]
- Предварительно строим все римские записи 1..3999 и ассоциируем мапой строку → число, что позволяет проверять «максимальный римский суффикс» у строки за счёт перебора суффиксов и поиска в словаре.[1]
- Предподсчитываем переходы nextRoman[prevNumber][ic] для каждой пары «текущее римское число, добавляемая буква», что критично для скорости основной ДП.[1]

Корректность :[1]
- Римский суффикс после добавления символа единственно определяется как самый длинный суффикс, являющийся корректной римской записью, что и моделирует переход nextRoman.[1]
- Максимум длины римской подстроки поддерживается монотонно как $$ \max $$ от предыдущего значения и длины нового римского суффикса, что эквивалентно определению максимальной римской подстроки в префиксах.[1]
- Линейность матожидания с подсчётом количества конфигураций даёт формулу ожидания через $$ f(n,k) $$ и равномерное число строк $$ 7^n $$.[1]

Реализация и детали модуля :[1]
- Используется двуслойная ДП на last×k для экономии памяти, модульные операции add/mul/pow/inv/div с модом $$ 998244353 $$.[1]
- Начальное состояние dp = 1, где «0» — пустая римская строка, длиной 0.[1]
- В конце суммируем по last и k, затем делим на $$ 7^n $$ с помощью обратного по модулю.[1]

Сложность :[1]
- Предподсчёт переходов: $$ O(4000 \cdot 7 \cdot L) $$, где L — длина проверяемых суффиксов (маленькая константа в среднем).[1]
- Основная ДП: $$ O(n \cdot 4000 \cdot 7 \cdot 16) $$, оценочно порядка $$ 7.5 \cdot 10^8 $$ элементарных операций в худшем случае, что требует агрессивной оптимизации (Ofast, unroll-loops, компактные типы).[1]

Подводные камни :[1]
- Корректность таблицы всех римских чисел 1..3999 и строгая каноничность записи важны для уникальности переходов.[1]
- Нельзя забывать, что last=0 соответствует пустому суффиксу, и переходы из него также допустимы.[1]
- Деление по модулю выполняется умножением на обратный элемент $$ 7^{-n} $$, прямое деление недопустимо.[1]

Полезные фрагменты :[1]
- Переход при добавлении символа:
```cpp
int nextNumber = nextRoman[prevNumber][ic];
int L = (int)roman[nextNumber].size();
int nextAnswer = max(prevAnswer, L);
modAddTo(dpNext[nextNumber][nextAnswer], dpCurr[prevNumber][prevAnswer]);
```
.[1]

***

### B. Игра с тремя кучками и инверсиями букв

Постановка в терминах решения :[1]
- Есть три кучки с буквами на вершине, на каждом ходе выбираются две кучки, их размеры уменьшаются на 1, а буквы инвертируются функцией opposite (A↔B).[1]
- Возвращается идентификатор победителя при оптимальной игре, где ход невозможен означает поражение текущего игрока.[1]

Идея и инварианты :[1]
- Если на столе две одинаковые и одна отличная буквы, то ход единственный: нужно тронуть те две, что совпадают, после чего все три станут одинаковыми, и игра переходит в «симметрический» режим.[1]
- В режиме «все три вершины одинаковы» активный игрок волен выбирать любые две кучки, а затем у оппонента снова будет единственный ответ, то есть инициатор контролирует «пары» ходов и должен завести позицию в проигрыш для соперника.[1]

Полный разбор случаев (после доведения букв к одинаковым) :[1]
- Если все три размера чётные, текущий игрок проигрывает, так как каждое «сдвоенное» уменьшение на 2 приводит в позицию того же типа и паритет не даёт шанса сломать симметрию в свою пользу.[1]
- Отсортируем размеры по возрастанию и разберём крайние случаи пустот: если две кучки пусты, то ход невозможен и текущий игрок немедленно проигрывает.[1]
- Если ровно одна пустая кучка, то дальнейшие ходы однозначны и исход определяется чётностью второй кучки: чётная — проигрыш текущего, нечётная — выигрыш текущего.[1]
- Если среди трёх хотя бы две нечётные, у текущего игрока есть выигрышная стратегия, выбирая на каждом шаге две нечётные и сохраняя контроль.[1]
- Если одна кучка нечётная, две чётные, то выигрыш возможен тогда и только тогда, когда сумма чётных не меньше нечётной: выбирая каждый раз пару «чётная+нечётная», текущий игрок доводит до тупика соперника, иначе проигрывает.[1]

Корректность и интуиция :[1]
- Приведение букв к одинаковым фиксирует «структуру выбора» и позволяет анализировать только паритеты и нули, так как буквы потом зеркально следуют друг за другом.[1]
- Случай с одной нечётной редуцируется к ресурсу «масса чётных против размера нечётной», что даёт точное условие выигрыша.[1]

Реализация :[1]
- Сначала применяем единственный принудительный ход, когда есть «две одинаковые, одна другая», после чего все три вершины совпадают по букве.[1]
- Дальше пошагово применяем описанный разбор по паритетам и нулям с сортировкой размеров и возвратом победителя.[1]

Сложность :[1]
- Время и память — $$ O(1) $$, только константные вычисления и сравнения.[1]

Подводные камни :[1]
- Не забыть выполнить принудительный ход с «двумя одинаковыми» перед разбором, иначе логика по паритетам станет неверной.[1]
- Аккуратно обработать нулевые кучки и сортировку, чтобы не пропустить граничные случаи.[1]

Полезные фрагменты :[1]
```cpp
if (n1 % 2 == 0 && n2 % 2 == 0 && n3 % 2 == 0) return 1 - whoMakesMove;
if (n1 > n2) swap(n1, n2);
if (n1 > n3) swap(n1, n3);
if (n2 > n3) swap(n2, n3);
if (n1 == 0 && n2 == 0) return 1 - whoMakesMove;
if (n1 == 0) return (n2 % 2 == 0) ? (1 - whoMakesMove) : whoMakesMove;
if ((n1 % 2) + (n2 % 2) + (n3 % 2) >= 2) return whoMakesMove;
int odd = (n1 % 2 ? n1 : (n2 % 2 ? n2 : n3));
int evenSum = n1 + n2 + n3 - odd;
return (evenSum >= odd) ? whoMakesMove : (1 - whoMakesMove);
```
.[1]

***

### C. Уравнение с повторной суммой цифр

Задача в терминах решения :[1]
- Найти все $$ x \ge 1 $$, удовлетворяющие $$ x + S(x) + S(S(x)) + \dots + S^{(k)}(x) = n $$, где $$ S $$ — сумма цифр и $$ S^{(i)} $$ — $$ i $$-кратное применение $$ S $$.[1]

Идея :[1]
- Значение суммы цифр стремительно падает к однозначным числам 1..9, причём для $$ n \le 10^{12} $$ достаточно рассмотреть $$ S(x) \in [1, 9 \cdot 12] $$ в грубой оценке, потому что максимум суммы цифр достигается при 12 девятках.[1]
- Переберём возможные $$ s = S(x) $$, восстановим по уравнению $$ x = n - s - S(s) - S(S(s)) - \dots $$ учитывая, что хвост быстро стабилизируется $$ S(t) = t $$ и тогда остаток хвоста считается формулой, и в конце проверим, что $$ S(x) = s $$ и $$ x \ge 1 $$.[1]

Корректность :[1]
- Полный перебор по $$ s $$ корректен, так как каждое решение имеет конкретное $$ s = S(x) $$, а диапазон для $$ s $$ покрывает все возможные значения суммы цифр $$ x \le n $$ в заданных ограничениях.[1]
- Учет стабилизации $$ S(t) = t $$ даёт точный расчёт хвоста $$ (k - i + 1) \cdot t $$, без потерь.[1]

Реализация :[1]
- Рекурсивная или итеративная функция суммы цифр, безопасная по глубине для 12 разрядов в Python и константная в C++.[1]
- Для каждого $$ s \in  $$ вычисляется кандидат $$ x $$, затем проверка предиката и накопление решений, после чего сортировка и вывод.[1]

Сложность :[1]
- Время ~ $$ O(108 \cdot k) $$ на инстанс плюс стоимость вычислений суммы цифр для хвоста, практически константно для заданных ограничений, память $$ O(\#ans) $$.[1]

Подводные камни :[1]
- Обязательно проверять $$ x \ge 1 $$ и точное равенство $$ S(x) = s $$, иначе в список попадут ложные кандидаты.[1]
- Хвост нужно уметь досчитать формулой, когда $$ S(t) = t $$, иначе будет лишняя работа и возможные ошибки в индексации шагов.[1]

Фрагмент проверки кандидата :[1]
```cpp
int last = sumX, x = n - sumX;
for (int i = 2; i <= k; i++) {
    int cur = sumDigits(last);
    if (cur == last) { x -= (k - i + 1) * last; break; }
    x -= cur; last = cur;
}
if (x >= 1 && sumDigits(x) == sumX) answ.push_back(x);
```
.[1]

***

### E. Делители и минимальная система счисления для «EF»

Постановка в терминах решения :[1]
- Искомое значение «EF» в системе счисления с основанием base имеет десятичное значение $$ 14 \cdot base + 15 $$, и по условию оно должно делить $$ n $$.[1]

Идея :[1]
- Перебрать все делители $$ x $$ числа $$ n $$, для каждого положить $$ 14 \cdot base + 15 = x $$, откуда $$ base = \frac{x - 15}{14} $$, проверить целочисленность, условие $$ base \ge 16 $$ и выбрать минимальный base, если он существует, иначе ответ $$ -1 $$.[1]

Корректность :[1]
- Любое валидное «EF» обязано быть делителем $$ n $$ и единственным образом задаёт base, поэтому перебор делителей покрывает все варианты и даёт точный минимум.[1]

Реализация :[1]
- Стандартная факторизация за $$ O(\sqrt{n}) $$ с разложением на нижнюю/верхнюю половины, дающая отсортированный список делителей без дополнительных затрат.[1]
- Линейный проход по делителям, проверка равенства $$ 14 \cdot base + 15 = x $$ и порога $$ base \ge 16 $$, затем печать минимума либо $$ -1 $$.[1]

Сложность :[1]
- Время $$ O(\sqrt{n}) $$ на факторизацию плюс $$ O(\tau(n)) $$ на проверки, память $$ O(\tau(n)) $$ для хранения делителей, где $$ \tau(n) $$ — число делителей.[1]

Подводные камни :[1]
- Деление должно быть целочисленным, проверьте равенство обратной подстановкой, а не только по целочисленному делению, чтобы исключить некорректные остатки.[1]
- Не забудьте нижнюю границу $$ base \ge 16 $$ по условию систем счисления с цифрой F.[1]

Фрагмент проверки :[1]
```cpp
int base = (x - 15) / 14;
if (base >= 16 && 14 * base + 15 == x) minBase = min(minBase, base);
```
.[1]

***

### H. Две лягушки на круге, синхронные и одиночные прыжки

Модель движения :[1]
- Лягушки сидят на круге из $$ n $$ позиций, стартуют из $$ a $$ и $$ b $$, возможны одиночные шаги (вперёд/назад для каждой) со временами $$ t_1, t_2, t_3, t_4 $$, а также синхронные шаги навстречу со временами $$ t_5, t_6 $$ для разных направлений дуг.[1]
- Ключевое наблюдение: «одновременно» они реально могут двигаться только через операции с временами $$ t_5 $$ или $$ t_6 $$, все остальные — это по очереди, и суммарное время определяется минимумом «два одиночных шага самой быстрой» и «один синхронный шаг».[1]

Идея :[1]
- Пусть расстояние по выбранной дуге равно $$ dist $$, тогда за шаг «уменьшения расстояния на 2» стоимость равна $$ \min(2 \cdot \min(timeA, timeB), timeAB) $$, где timeAB — время синхронного шага по соответствующей дуге, а timeA/timeB — времена одиночных шагов лягушек по этой дуге в сторону друг друга.[1]
- Пока $$ dist \ge 2 $$ платим блоками по 2, при $$ dist = 1 $$ платим $$ \min(timeA, timeB) $$ за последний одиночный шаг, а ещё рассматриваем «выгодный бэкстеп»: иногда выгодно сначала увеличить расстояние на 1, заплатив $$ \min(timeA^{-1}, timeB^{-1}) $$, а потом идти штатно.[1]

Алгоритм :[1]
- Рассчитать дуги AB и BA как направленные расстояния на круге, для каждой дуги посчитать два варианта: «сразу сближаться» и «шаг назад, затем сближаться», взять минимум из четырёх сценариев.[1]
- Подсчёт стоимости по фиксированному $$ dist $$: 
$$
cost(dist) = \left\lfloor \frac{dist}{2} \right\rfloor \cdot \min\big(timeAB,\ 2 \cdot \min(timeA, timeB)\big) + \big(dist \bmod 2\big) \cdot \min(timeA, timeB)
$$ 
.[1]

Корректность :[1]
- Полный перебор двух дуг и двух режимов (прямо/с бэкстепом) покрывает все оптимальные стратегии благодаря аддитивности стоимости укорочения дистанции и независимости выбора «где сделать бэкстеп» по структуре дуги.[1]
- Формула стоимости по блокам «минус 2» корректно учитывает «или синхронно, или два одиночных шага самой быстрой» как доминирующие способы сокращать расстояние.[1]

Сложность :[1]
- Время и память — $$ O(1) $$, так как вычисляется фиксированная формула по четырём сценариям.[1]

Подводные камни и примечания к Python :[1]
- Правильно сопоставьте какие времена соответствуют какой дуге: AB использует набор $$ (t_1, t_4, t_2, t_3, t_5) $$, BA — $$ (t_2, t_3, t_1, t_4, t_6) $$ согласно направлениям.[1]
- В Python нет перегрузки, поэтому функции должны иметь разные имена, и используйте быстрый ввод/вывод, если обрабатывается много тестов.[1]

Полезные фрагменты :[1]
```cpp
int per2 = min<int>(timeMeet, 2 * min<int>(timeA, timeB));
int ans = (dist / 2) * per2 + (dist % 2 ? min<int>(timeA, timeB) : 0);
int withBack = solve(dist + 1, timeA, timeB, timeMeet) + min<int>(timeAinv, timeBinv);
return min(ans, withBack);
```
.[1]

***

### I. Интерактив: делимость через «запрос 1» и фильтрация кандидатов

Интерактивная механика (по коду и комментариям) :[1]
- Всего 300 запросов, что совпадает с числом простых до 1986, и это не случайно обыгрывается в комментарии.[1]
- Замысел: первым делом задаём запрос «1», чтобы гарантировать, что «1» будет среди напечатанных НОД, и тогда для любого простого $$ p $$ значение $$ \gcd(x, p) \in \{1, p\} $$ позволит однозначно понять делимость $$ x $$ на $$ p $$ по ответу жюри, сообщающему «был ли этот НОД уже напечатан» в виде 1/0 с учетом того, что 1 уже точно был.[1]

Идея :[1]
- Вести массив кандидатов $$ \{1,2,\dots,1986\} $$, на каждом шаге брать $$ p $$ как второй элемент массива (фактически возрастающий перебор), спрашивать про $$ p $$ и фильтровать кандидатов по делимости на $$ p $$ согласно ответу, пока не останется один элемент.[1]

Корректность :[1]
- После запроса «1» ответы 0/1 на простых $$ p $$ точно кодируют факт делимости $$ x $$ на $$ p $$, что обеспечивает корректную фильтрацию множества кандидатов вплоть до единственного элемента.[1]

Реализация и интерактивные детали :[1]
- На каждый запрос печатается «? v», считывается ответ, а при сообщении решения — «! x», не забывайте flush в Python и endl в C++.[1]
- Для устойчивости по ограничениям можно перебирать последовательность «простые/их степени», однако описанная стратегия уже укладывается в лимит и проходит по времени.[1]

Сложность :[1]
- Количество запросов на один тест ограничено сверху небольшой константой, в пределах 300, фильтрация списка — линейная, что укладывается в лимит.[1]

Подводные камни :[1]
- Не забыть сделать первый запрос «1», иначе двузначность ответов по $$ \gcd(x,p) $$ нарушит логику фильтрации.[1]
- Корректно поддерживать массив кандидатов in‑place или пересборкой нового списка, чтобы не допустить ошибок инвариантов.[1]

Фрагмент фильтрации :[1]
```cpp
int p = candidates[1];
int res = ask(p);
int len = 0;
for (int v : candidates)
    if ((v % p == 0) == (res == 0))
        candidates[len++] = v;
candidates.resize(len);
```
.[1]

***

### M. Добивание остатка по модулю 60 двусторонними добавлениями (BFS)

Постановка в терминах решения :[1]
- Дана строка из {A..F} как шестнадцатеричные цифры 10..15, разрешено добавлять буквы в начало или конец, цель — добиться делимости на 60, при этом среди кратчайших решений вывести лексикографически минимальную «сводку добавлений» в порядке A..F либо «OK», если добавления не нужны.[1]

Идея :[1]
- Работать в пространстве состояний «длина, остаток по модулю 60», так как переходы при добавлении слева/справа вычисляются формулами на остатки и длину, а ответа требуется немного, потому что целевой остаток 0 «близок» в цикле по 60.[1]
- Запустить BFS от стартового состояния, на каждом шаге генерировать 12 переходов: 6 букв в конец и 6 букв в начало, отслеживая лучший по длине уровень, и на нём собирать все варианты подсчёта букв для лексикографического минимума.[1]

Переходы остатков :[1]
- Добавление справа цифры $$ d \in \{10..15\} $$: $$ rem' = (rem \cdot 16 + d) \bmod 60 $$.[1]
- Добавление слева: $$ rem' = (d \cdot 16^{len} + rem) \bmod 60 $$ с вычислением $$ 16^{len} \bmod 60 $$ быстрым возведением в степень.[1]

Корректность :[1]
- BFS по состояниям (len, rem) минимизирует длину добавлений, а сбор всех ответов на минимальной длине и выбор минимума по строке «сводки» даёт ровно требуемую спецификацию задачи.[1]
- Формулы переходов непосредственно следуют из арифметики позиционных систем при конкатенации слева/справа.[1]

Реализация :[1]
- Функции convert(s) для получения начального (len, rem), digit для перевода A..F в 10..15, modPow/pow для вычислений, очередь состояний хранит также массив счётчиков по 6 буквам для последующего формирования ответа.[1]
- При достижении rem=0 обновляется лучшая длина и копится строка arrToStr(cnt), после завершения берётся минимум; пустой набор преобразуется в «OK».[1]

Сложность :[1]
- Состояний не более «несколько уровней» до достижения rem=0, каждый уровень порождает до 12 переходов, на практике очень быстро находя минимальную длину, память пропорциональна числу посещённых состояний и собранных ответов на лучшем уровне.[1]

Подводные камни и примечания к Python :[1]
- В Python обязательно копировать список счётчиков при enqueuing, чтобы избежать aliasing между путями, иначе ответы испортятся из-за общей мутабельности.[1]
- Важно отсечь обработку состояний с длиной ≥ текущего лучшего ответа, чтобы не раздувать поиск за пределы оптимального уровня.[1]

Фрагменты формул :[1]
- Переходы:
```python
newRemRight = (rem * 16 + d) % 60
newRemLeft  = (pow(16, length, 60) * d + rem) % 60
```
.[1]
- Формирование ответа:
```python
res = ''.join(chr(ord('A') + i) * cnt[i] for i in range(6))
print(res if res else "OK")
```
.[1]

***

### Приложение: замеры, модули, и детали реализации из решений

- Указанные решения прошли с вердиктом OK с характерными лимитами времени/памяти: A: 0.843 c / 4 MB, B: 0.039 c / 2 MB (C++), 0.518 c / 114 MB (Python), C: 0.005 c / 2 MB (C++), 0.130 c / 111 MB (Python), E: 0.013 c / 2 MB (C++), 0.068 c / 105 MB (Python), H: 0.059 c / 2 MB (C++), 0.400 c / 120 MB (Python), I: 0.030 c / 2 MB (C++), 0.173 c / 110 MB (Python), M: 0.006 c / 2.4 MB (C++), 0.088 c / 111 MB (Python), что соответствует описанной сложности и выбранным структурам данных.[1]
- Для задачи A используется модуль $$ 998244353 $$, модульная арифметика реализована стандартными степенями и обратными элементами через возведение в степень $$ y^{mod-2} $$ по малой теореме Ферма, деление выполняется как умножение на обратный элемент.[1]
- Мелкие, но практичные оптимизации: предвычисление таблиц переходов (A), аккуратная сортировка и ранние возвраты по крайним случаям (B), досчёт стационарного хвоста суммы цифр формулой (C), $$ O(\sqrt{n}) $$ факторизация с двумя половинами делителей (E), ровно четыре сценария для минимума по дугам и бэкстепу (H), обязательный «? 1» в интерактиве (I), срез поиска по лучшей длине и лексикографический минимум по агрегированным буквам (M).[1]

[1](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/69856375/ffe22dfe-ffa3-461d-a3d5-5e7aa1a19db4/paste.txt)