#include <bits/stdc++.h>
#define all(x) (x).begin(),(x).end()
#define isz(x) (int)(x).size()
using namespace std;
using vi = vector<int>;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int tt; cin >> tt;
    while (tt --> 0) {
        string s; cin >> s;
        // итак, у нас должны выполняться условия на равенство, например,
        // s[i] == s[n - i - 1] (из палиндромности)
        // также для каждого предыдущего уровня палиндромности аналогичные условия
        // объединяя все условия, мы можем сказать, какие позиции должны быть равны
        // между собой. например:
        // 010201030102010 означает:
        // 0: s[0] == s[2] == s[4] == s[6] == s[8] == s[10] == s[12] == s[14]
        // 1: s[1] == s[5] == s[9] == s[13]
        // 2: s[3] == s[11]
        // 3: s[7]
        // можем запустить поиск в ширину, или поиск в глубину, чтобы найти
        // компоненты равных индексов
        // в каждой компоненте мы должны сделать одну и ту же букву. выгоднее
        // всего заменять все остальные буквы на букву с максимальным количеством
        
        // решение стартует здесь:
        // собираем компоненты с одинаковыми буквами:
        map<int, vi> comp;
        function<void(int,int,int)> dfs = [&](int L, int R, int d)
        {
            int m = (L+R)/2;
            comp[d].push_back(m);
            if (R - L + 1 > 1) {
                dfs(L, m-1, d+1);
                dfs(m+1, R, d+1);
            }
        };
        dfs(0, isz(s)-1, 0);
        // обходим каждую компоненту:
        int answ{};
        for (auto &[_, ids] : comp) {
            vi cnt(26);
            for (auto i : ids)
                cnt[s[i]-'a']++;
            // в ответ идёт сумма минус максимум
            int sum = accumulate(all(cnt), 0);
            int max = *max_element(all(cnt));
            answ += sum - max;
        }
        cout << answ << '\n';
    }
    return 0;
}