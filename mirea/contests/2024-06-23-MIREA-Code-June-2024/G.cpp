#include <bits/stdc++.h>
using namespace std;
const int mod = 998244353;
void solve() {
    // читаем данные
    int n; cin >> n;
    vector<int> a(n);
    for (auto &it : a)
        cin >> it;
    // сортируем вектор по возрастанию
    sort(a.begin(), a.end());
    // понадобятся степени двойки, предподсчитаем их
    vector<int> pow2(n+1, 1);
    for (int i = 1; i <= n; i++)
        pow2[i] = int(pow2[i-1] * 2LL % mod);
    // для каждого элемента считаем в сколько подпоследовательностей он входит и
    // на какой позиции
    int answ = 0;
    for (int i = 0; i < n; i++) {
        int right = pow2[n - i - 1];
        // до него i элементов, которые меньше его
        // можем выбрать от 0 до i элементов перед ним
        // C(i, 0) * 1 + C(i, 1) * 2 + C(i, 2) * 3 + ... + C(i, i) * (i+1)
        // треугольник паскаля
        // 1
        // 1 1
        // 1 2 1
        // 1 3 3 1
        // 1 4 6 4 1
        // 1 5 10 10 5 1
        // распишем сумму:
        // 1*1+5*2+10*3+10*4+5*5+1*6
        // используя симметричность, раскидаем коэффициенты поровну:
        // 1*3.5+5*3.5+10*3.5+10*3.5+5*3.5+1*3.5
        // вынесем 3.5: 3.5 * (1+5+10+10+5+1) = 3.5 * 2^i = (i+2) * 2^(i-1)
        int left = 1;
        if (i > 0)
            left = int((i+2LL) * pow2[i-1] % mod);
        // считаем общее кол-во подпоследовательностей уже с весами:
        int cnt = int(left * 1LL * right % mod);
        // прибавляем к ответу:
        (answ += int(cnt * 1LL * a[i] % mod)) %= mod;
    }
    // выводим ответ:
    cout << (answ%mod+mod)%mod << endl;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int tt; cin >> tt;
    while (tt --> 0)
        solve();
}