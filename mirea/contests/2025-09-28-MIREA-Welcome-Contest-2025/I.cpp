#include <bits/stdc++.h>

#define isz(x) (int)(x).size()

const int mod = (int)1e9+7;

int binpow(int a, int64_t e) {
    int res = 1;
    while (e > 0) {
        if (e & 1)
            res = int(res * 1LL * a % mod);
        a = int(a * 1LL * a % mod);
        e >>= 1;
    }
    return res;
}

int formula(int64_t n, int k = 4) {
// считает количество строк длины n, у которых заданная строка "имя" длины k
// является подпоследовательностью. Возвращает ответ взятый по простому модулю
// mod. Ответ не зависит от содержимого имени и какие буквы в каком порядке там
// даны. Ответ зависит только от размера алфавита.

// Идея: из всех строк (их 26^n) вычтем те строки, в которых наша
// подпоследовательность набрана частично:
// - вычитаем строки, в которых 0 символов набрано
// - вычитаем строки, в которых 1 символ набран
// - вычитаем строки, в которых 2 символа набраны
// ...
// - вычитаем строки, в которых k-1 символов набраны
// Количество строк, в которых набрано t символов - это C(n, t) * 25^(n-t)
// Эту формулу можно понять следующим образом: у нас есть t позиций в которых
// оказался именно тот символ, которых мы ожидали (следующий символ в
// подпоследовательности), он один такой
// а во всех остальных позициях всё время оказывался не тот символ,
// которого мы ожидали, то есть один из 25 оставшихся символов
    if (n < k)
        return 0;
    if (n == k)
        return 1;
    int64_t res = binpow(26, n);
    int rn = int(n % mod);
    int64_t Cni = 1;
    for (int i = 0; i < k; i++) {
        res -= Cni * binpow(25, n - i) % mod;
        (Cni *= (rn - i + mod) % mod) %= mod;
        (Cni *= binpow(i+1, mod-2)) %= mod;
    }
    return int((res % mod + mod) % mod);
}

void solve() {
    int k; std::cin >> k;
    std::string name; int64_t n;
    std::cin >> name >> n;
    assert(k == isz(name));
    std::cout << formula(n, isz(name)) << '\n';
}

main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    int tt; std::cin >> tt;
    while (tt --> 0) solve();
}
