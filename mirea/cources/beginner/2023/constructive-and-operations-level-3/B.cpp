#include <bits/stdc++.h>
using namespace std;
int main() {    
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    string s; cin >> s;
    // посчитаем количество каждой буквы
    vector<int> count(26);
    for (auto it : s) count[it-'a']++;
    // чтобы получить палиндром, надо, чтобы каждого символа было чётное кол-во
    // и какой-то один символ был нечётного количества. для достижения минимально
    // лексикографического ответа мы должны заменять максимальные символы (вроде z)
    // которые входят нечётное количество на минимальные символы (вроде a), которые
    // тоже входят нечётное кол-во, пока условие выше не выполнится
    int l = 0, r = 25;
    while (true) {
        while (l < 26 && count[l] % 2 == 0) ++l;
        while (r >= l && count[r] % 2 == 0) --r;
        // l = минимальный символ, входящий нечётное число раз
        // r = максимальный символ, входящий нечётное число раз
        if (l >= r) break;
        // здесь l < r, поэтому l и r два различных нечётных символа
        // далем одну замену r --> l
        count[l]++;
        count[r]--;
    }
    // строим палиндром. для достижения лексикографически минимального ответа
    // надо сначала добавлять минимально возможные символы
    // Строим левую половину палиндрома:
    string s1;
    for (int i = 0; i < 26; ++i)
        s1 += string(count[i] / 2, 'a'+i);
    // строим правую половину, симметричную ей:
    string s2 = s1;
    reverse(s2.begin(), s2.end());    
    // накидываем нечётные символы между половинами (он такой один, нечётный символ):
    for (int i = 0; i < 26; ++i)
        if (count[i] % 2 == 1) {
            s1 += char('a'+i);
            break;
        }
    // выводим ответ:
    cout << s1 << s2 << endl;
    return 0;
}