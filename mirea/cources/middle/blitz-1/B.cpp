#include <bits/stdc++.h>
using namespace std;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    // весь массив без одного элемента это некоторый префикс & некоторый суффикс
    // то есть, если мы удаляем i-й элемент, а pref[i] = a[0] & a[1] & ... & a[i]
    // а suff[i] = a[i] & a[i+1] & a[i+2] & ... & a[n-1], то ответ для этого варианта
    // это pref[i-1] & suff[i+1]
    // Научились за O(1) получает ответ для одного варианта удаления, таких вариантов n
    // переберём каждый вариант и найдём максимум среди них
    
    // читаем данные + предподсчитываем побитовое И на префиксе
    // ~0u это инверсия битов в числе ноль беззнакового типа, то есть это число,
    // состоящее из всех единиц - нейтральный элемент для побитового И
    int n; cin >> n;
    vector<uint32_t> a(1+n+1), p(1+n+1, ~0u), s(1+n+1, ~0u);
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        p[i] = p[i-1] & a[i];
    }
    // предподсчитываем побитовое И на суффиксе:
    for (int i = n; i >= 1; i--)
        s[i] = s[i+1] & a[i];
    // находим максимальный ответ + выводим его:
    uint32_t answ{};
    for (int i = 1; i <= n; i++)
        answ = max(answ, p[i-1] & s[i+1]);
    cout << answ << endl;
}
