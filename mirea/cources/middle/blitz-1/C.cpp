// двигаясь из s в f мы мало что посчитаем, поэтому надо двигаться из конца в начало
// мы будем искать путь, проделывая обратные шаги: извлечение квадрата и движения +-1
#include <bits/stdc++.h>
using namespace std;
int64_t solve(int64_t s, int64_t f) {
    int64_t res = abs(f-s); // первый вариант не использовать квадраты
    if (s >= f) // он же может быть самым оптимальным
        return res;
    // дальше будем юзать квадраты
    // мы идём до двух контрольных точек: до ближайшего квадрата сверху от f,
    // и затем извлекаем квадрат и делаем рекурсивный вызов, либо до ближайшего
    // квадрата снизу от f, затем извлекаем квадрат и делаем рекурсивный вызов
    int64_t root = sqrtl(f);
    // вниз + извлечь квадрат:
    if (f != root) // не допускаем рекурсивного вызова (s,f) из (s,f) - бесконечная рекурсия
        res = min(res, f-root*root+1+solve(s,root));
    // вверх + извлечь квадрат:
    if (f != root+1) // не допускаем рекурсивного вызова (s,f) из (s,f) - бесконечная рекурсия
        res = min(res, (root+1)*(root+1)-f+1+solve(s,root+1));
    return res;
}
int main() {
    int64_t start, finish;
    cin >> start >> finish;
    cout << solve(start, finish) << endl;
}
